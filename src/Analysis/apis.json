[
    {
        "class": "android.bluetooth.BluetoothProfile",
        "api": "getConnectedDevices",
        "permissionText": "Return the set of devices which are in state STATE_CONNECTED\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothProfile",
        "api": "getConnectionState",
        "permissionText": "Get the current connection state of the profile\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothProfile",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "If none of the devices match any of the given states,\n an empty list will be returned.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothManager",
        "api": "getConnectedDevices",
        "permissionText": "This is not specific to any application configuration but represents\n the connection state of Bluetooth for this profile.\n This can be used by applications like status bar which would just like\n to know the state of Bluetooth.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothManager",
        "api": "getConnectionState",
        "permissionText": "This is not specific to any application configuration but represents\n the connection state of the local Bluetooth adapter for certain profile.\n This can be used by applications like status bar which would just like\n to know the state of Bluetooth.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothManager",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "This is not specific to any application configuration but represents\n the connection state of the local Bluetooth adapter for this profile.\n This can be used by applications like status bar which would just like\n to know the state of the local adapter.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeScanner",
        "api": "startScan",
        "permissionText": "When the PendingIntent is delivered, the Intent passed to the receiver or activity\n will contain one or more of the extras EXTRA_CALLBACK_TYPE,\n EXTRA_ERROR_CODE and EXTRA_LIST_SCAN_RESULT to indicate the result of\n the scan.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeScanner",
        "api": "startScan",
        "permissionText": "An app must hold\n ACCESS_COARSE_LOCATION or\n ACCESS_FINE_LOCATION permission\n in order to get results.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeScanner",
        "api": "startScan",
        "permissionText": "An app must hold\n ACCESS_COARSE_LOCATION or\n ACCESS_FINE_LOCATION permission\n in order to get results.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeScanner",
        "api": "stopScan",
        "permissionText": "Stops an ongoing Bluetooth LE scan.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeScanner",
        "api": "stopScan",
        "permissionText": "Stops an ongoing Bluetooth LE scan started using a PendingIntent. When creating the\n PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT flag. Otherwise, the stop\n scan may have no effect.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeAdvertiser",
        "api": "startAdvertising",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN permission."
    },
    {
        "class": "android.bluetooth.le.BluetoothLeAdvertiser",
        "api": "startAdvertising",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.le.BluetoothLeAdvertiser",
        "api": "stopAdvertising",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN permission."
    },
    {
        "class": "android.bluetooth.BluetoothHidDevice",
        "api": "ACTION_CONNECTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission to receive."
    },
    {
        "class": "android.bluetooth.BluetoothHidDevice",
        "api": "getConnectedDevices",
        "permissionText": "Return the set of devices which are in state STATE_CONNECTED\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHidDevice",
        "api": "getConnectionState",
        "permissionText": "Get the current connection state of the profile\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHidDevice",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "If none of the devices match any of the given states,\n an empty list will be returned.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHearingAid",
        "api": "ACTION_CONNECTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission to\n receive."
    },
    {
        "class": "android.bluetooth.BluetoothHearingAid",
        "api": "getConnectedDevices",
        "permissionText": "Return the set of devices which are in state STATE_CONNECTED\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHearingAid",
        "api": "getConnectionState",
        "permissionText": "Get the current connection state of the profile\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHearingAid",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "If none of the devices match any of the given states,\n an empty list will be returned.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "connectChannelToSource",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "disconnectChannel",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "getConnectedDevices",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission.\n\n This is not specific to any application configuration but represents the connection\n state of the local Bluetooth adapter for this profile. This can be used\n by applications like status bar which would just like to know the state of the\n local adapter."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "getConnectionState",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission.\n\n This is not specific to any application configuration but represents the connection\n state of the local Bluetooth adapter with the remote device. This can be used\n by applications like status bar which would just like to know the state of the\n local adapter."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission.\n This is not specific to any application configuration but represents the connection\n state of the local Bluetooth adapter for this profile. This can be used\n by applications like status bar which would just like to know the state of the\n local adapter."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "getMainChannelFd",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "registerSinkAppConfiguration",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHealth",
        "api": "unregisterAppConfiguration",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "ACTION_AUDIO_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission\n to receive."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "ACTION_CONNECTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission to\n receive."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "ACTION_VENDOR_SPECIFIC_HEADSET_EVENT",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission\n to receive."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "getConnectedDevices",
        "permissionText": "Return the set of devices which are in state STATE_CONNECTED\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "getConnectionState",
        "permissionText": "Get the current connection state of the profile\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "If none of the devices match any of the given states,\n an empty list will be returned.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "isAudioConnected",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "sendVendorSpecificResultCode",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "startVoiceRecognition",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothHeadset",
        "api": "stopVoiceRecognition",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattService",
        "api": "BluetoothGattService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattService",
        "api": "addCharacteristic",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattService",
        "api": "addService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "addService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "cancelConnection",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "clearServices",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "connect",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "getService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "getServices",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "notifyCharacteristicChanged",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "removeService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattServer",
        "api": "sendResponse",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattDescriptor",
        "api": "BluetoothGattDescriptor",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattCharacteristic",
        "api": "BluetoothGattCharacteristic",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGattCharacteristic",
        "api": "addDescriptor",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "abortReliableWrite",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "beginReliableWrite",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "disconnect",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "discoverServices",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "executeReliableWrite",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "getService",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "getServices",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "readCharacteristic",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "readDescriptor",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "readRemoteRssi",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "requestMtu",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "setCharacteristicNotification",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "writeCharacteristic",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothGatt",
        "api": "writeDescriptor",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_ACL_CONNECTED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_ACL_DISCONNECTED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_ACL_DISCONNECT_REQUESTED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_BOND_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_CLASS_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_FOUND",
        "permissionText": "Requires Manifest.permission.BLUETOOTH and\n Manifest.permission.ACCESS_COARSE_LOCATION to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_NAME_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_PAIRING_REQUEST",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN to\n receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "ACTION_UUID",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN to receive."
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "createBond",
        "permissionText": "Android system services will handle the necessary user interactions\n to confirm and complete the bonding process.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "createInsecureL2capChannel",
        "permissionText": "The communication channel may not have an authenticated link key, i.e. it may be subject\n to man-in-the-middle attacks. Use createL2capChannel(int) if an encrypted and\n authenticated communication channel is possible.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "createInsecureRfcommSocketToServiceRecord",
        "permissionText": "Hint: If you are connecting to a Bluetooth serial board then try\n using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.\n However if you are connecting to an Android peer then please generate\n your own unique UUID.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "createL2capChannel",
        "permissionText": "Use this socket if an authenticated socket link is possible. Authentication refers\n to the authentication of the link key to prevent man-in-the-middle type of attacks.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "createRfcommSocketToServiceRecord",
        "permissionText": "Hint: If you are connecting to a Bluetooth serial board then try\n using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.\n However if you are connecting to an Android peer then please generate\n your own unique UUID.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "fetchUuidsWithSdp",
        "permissionText": "This API is asynchronous and ACTION_UUID intent is sent,\n with the UUIDs supported by the remote end. If there is an error\n in getting the SDP records or if the process takes a long time,\n ACTION_UUID intent is sent with the UUIDs that is currently\n present in the cache. Clients should use the getUuids() to get UUIDs\n if service discovery is not to be performed.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "getBluetoothClass",
        "permissionText": "Get the Bluetooth class of the remote device.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "getBondState",
        "permissionText": "Possible values for the bond state are:\n BOND_NONE,\n BOND_BONDING,\n BOND_BONDED.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "getName",
        "permissionText": "The local adapter will automatically retrieve remote names when\n performing a device scan, and will cache them. This method just returns\n the name for this device from the cache.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "getType",
        "permissionText": "Get the Bluetooth device type of the remote device.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "getUuids",
        "permissionText": "Use fetchUuidsWithSdp() if fresh UUIDs are desired.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "setPairingConfirmation",
        "permissionText": "Confirm passkey for PAIRING_VARIANT_PASSKEY_CONFIRMATION pairing.\n\n \n Requires Manifest.permission.BLUETOOTH_PRIVILEGED"
    },
    {
        "class": "android.bluetooth.BluetoothDevice",
        "api": "setPin",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_CONNECTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_DISCOVERY_FINISHED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_DISCOVERY_STARTED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_LOCAL_NAME_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_REQUEST_DISCOVERABLE",
        "permissionText": "Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_REQUEST_ENABLE",
        "permissionText": "Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_SCAN_MODE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "ACTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH to receive."
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "cancelDiscovery",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return false. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "disable",
        "permissionText": "This is an asynchronous call: it will return immediately, and\n clients should listen for ACTION_STATE_CHANGED\n to be notified of subsequent adapter state changes. If this call returns\n true, then the adapter state will immediately transition from STATE_ON to STATE_TURNING_OFF, and some time\n later transition to either STATE_OFF or STATE_ON. If this call returns false then there was an\n immediate problem that will prevent the adapter from being turned off -\n such as the adapter already being turned off.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "enable",
        "permissionText": "This is an asynchronous call: it will return immediately, and\n clients should listen for ACTION_STATE_CHANGED\n to be notified of subsequent adapter state changes. If this call returns\n true, then the adapter state will immediately transition from STATE_OFF to STATE_TURNING_ON, and some time\n later transition to either STATE_OFF or STATE_ON. If this call returns false then there was an\n immediate problem that will prevent the adapter from being turned on -\n such as Airplane mode, or the adapter is already turned on.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getAddress",
        "permissionText": "For example, \"00:11:22:AA:BB:CC\".\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getBondedDevices",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return an empty set. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getName",
        "permissionText": "Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getProfileConnectionState",
        "permissionText": "Return value can be one of\n BluetoothProfile#STATE_DISCONNECTED,\n BluetoothProfile#STATE_CONNECTING,\n BluetoothProfile#STATE_CONNECTED,\n BluetoothProfile#STATE_DISCONNECTING\n \n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getScanMode",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return SCAN_MODE_NONE. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "getState",
        "permissionText": "Possible return values are\n STATE_OFF,\n STATE_TURNING_ON,\n STATE_ON,\n STATE_TURNING_OFF.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "isDiscovering",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return false. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "isEnabled",
        "permissionText": "Equivalent to:\n getBluetoothState() == STATE_ON\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "listenUsingInsecureL2capChannel",
        "permissionText": "Use BluetoothDevice#createInsecureL2capChannel(int) to connect to this server\n socket from another Android device that is given the PSM value.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "listenUsingInsecureRfcommWithServiceRecord",
        "permissionText": "Use BluetoothDevice#createRfcommSocketToServiceRecord to\n connect to this socket from another device using the same UUID.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "listenUsingL2capChannel",
        "permissionText": "Use BluetoothDevice#createL2capChannel(int) to connect to this server\n socket from another Android device that is given the PSM value.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "listenUsingRfcommWithServiceRecord",
        "permissionText": "Use BluetoothDevice#createRfcommSocketToServiceRecord to\n connect to this socket from another device using the same UUID.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "setName",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return false. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "startDiscovery",
        "permissionText": "If Bluetooth state is not STATE_ON, this API\n will return false. After turning on Bluetooth,\n wait for ACTION_STATE_CHANGED with STATE_ON\n to get the updated value.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "startLeScan",
        "permissionText": "Devices which advertise all specified services are reported using the\n LeScanCallback#onLeScan callback.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "startLeScan",
        "permissionText": "Results of the scan are reported using the\n LeScanCallback#onLeScan callback.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothAdapter",
        "api": "stopLeScan",
        "permissionText": "Stops an ongoing Bluetooth LE device scan.\n\n \n Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "ACTION_CONNECTION_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission to\n receive."
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "ACTION_PLAYING_STATE_CHANGED",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission to\n receive."
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "getConnectedDevices",
        "permissionText": "Return the set of devices which are in state STATE_CONNECTED\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "getConnectionState",
        "permissionText": "Get the current connection state of the profile\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "getDevicesMatchingConnectionStates",
        "permissionText": "If none of the devices match any of the given states,\n an empty list will be returned.\n\n \n Requires Manifest.permission.BLUETOOTH"
    },
    {
        "class": "android.bluetooth.BluetoothA2dp",
        "api": "isA2dpPlaying",
        "permissionText": "Requires Manifest.permission.BLUETOOTH permission."
    },
    {
        "class": "android.hardware.biometrics.BiometricPrompt",
        "api": "authenticate",
        "permissionText": "This call warms up the biometric hardware, displays a system-provided dialog, and starts\n scanning for a biometric. It terminates when AuthenticationCallback#onAuthenticationError(int, CharSequence) is called, when AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult) is called, or when\n the user dismisses the system-provided dialog.  This operation can be canceled by using the\n provided cancel object. The application will receive authentication errors through AuthenticationCallback, and button events through the corresponding callback set in Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener).  It is\n safe to reuse the BiometricPrompt object, and calling BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback) while\n an existing authentication attempt is occurring will stop the previous client and start a new\n authentication. The interrupted client will receive a cancelled notification through AuthenticationCallback#onAuthenticationError(int, CharSequence).\n\n Note: Applications generally should not cancel and start authentication in quick succession.\n For example, to properly handle authentication across configuration changes, it's recommended\n to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the\n application will not need to cancel/restart authentication during the configuration change.\n\n \n Requires Manifest.permission.USE_BIOMETRIC"
    },
    {
        "class": "android.hardware.biometrics.BiometricPrompt",
        "api": "authenticate",
        "permissionText": "This call warms up the biometric hardware, displays a system-provided dialog, and starts\n scanning for a biometric. It terminates when AuthenticationCallback#onAuthenticationError(int, CharSequence) is called, when AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult), or when the user\n dismisses the system-provided dialog, at which point the crypto object becomes invalid. This\n operation can be canceled by using the provided cancel object. The application will receive\n authentication errors through AuthenticationCallback, and button events through the\n corresponding callback set in Builder#setNegativeButton(CharSequence, Executor,\n DialogInterface.OnClickListener). It is safe to reuse the BiometricPrompt object,\n and calling BiometricPrompt#authenticate( CancellationSignal, Executor,\n AuthenticationCallback) while an existing authentication attempt is occurring will stop the\n previous client and start a new authentication. The interrupted client will receive a\n cancelled notification through AuthenticationCallback#onAuthenticationError(int,\n CharSequence).\n\n Note: Applications generally should not cancel and start authentication in quick succession.\n For example, to properly handle authentication across configuration changes, it's recommended\n to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so, the\n application will not need to cancel/restart authentication during the configuration change.\n\n \n Requires Manifest.permission.USE_BIOMETRIC"
    },
    {
        "class": "android.hardware.biometrics.BiometricManager",
        "api": "canAuthenticate",
        "permissionText": "Determine if biometrics can be used. In other words, determine if BiometricPrompt\n can be expected to be shown (hardware available, templates enrolled, user-enabled).\n\n \n Requires Manifest.permission.USE_BIOMETRIC"
    },
    {
        "class": "android.service.autofill.AutofillService",
        "api": "SERVICE_INTERFACE",
        "permissionText": "The Intent that must be declared as handled by the service.\n To be supported, the service must also require the\n Manifest.permission.BIND_AUTOFILL_SERVICE permission so\n that other applications can not abuse it."
    },
    {
        "class": "android.media.AudioManager",
        "api": "startBluetoothSco",
        "permissionText": "Requires Permission:\n   Manifest.permission.MODIFY_AUDIO_SETTINGS."
    },
    {
        "class": "android.media.AudioManager",
        "api": "stopBluetoothSco",
        "permissionText": "Requires Permission:\n   Manifest.permission.MODIFY_AUDIO_SETTINGS."
    },
    {
        "class": "android.appwidget.AppWidgetManager",
        "api": "bindAppWidgetIdIfAllowed",
        "permissionText": "Note: You need the Manifest.permission.BIND_APPWIDGET\n permission or the user must have enabled binding widgets always for your component.\n Should be used by apps that host widgets. If this method returns false, call ACTION_APPWIDGET_BIND to request permission to bind."
    },
    {
        "class": "android.content.pm.ApplicationInfo",
        "api": "FLAG_FACTORY_TEST",
        "permissionText": "Value for flags: set to true if this application holds the\n Manifest.permission.FACTORY_TEST permission and the\n device is running in factory test mode."
    },
    {
        "class": "android.app.AlarmManager",
        "api": "setTime",
        "permissionText": "Set the system wall clock time.\n Requires the permission android.permission.SET_TIME.\n\n \n Requires Manifest.permission.SET_TIME"
    },
    {
        "class": "android.app.AlarmManager",
        "api": "setTimeZone",
        "permissionText": "On android M and above, it is an error to pass in a non-Olson timezone to this\n function. Note that this is a bad idea on all Android releases because POSIX and\n the TimeZone class have opposite interpretations of '+' and '-'\n in the same non-Olson ID.\n\n \n Requires Manifest.permission.SET_TIME_ZONE"
    },
    {
        "class": "android.bluetooth.le.AdvertisingSet",
        "api": "enableAdvertising",
        "permissionText": "Requires Manifest.permission.BLUETOOTH_ADMIN"
    },
    {
        "class": "android.app.ActivityManager",
        "api": "dumpPackageState",
        "permissionText": "Perform a system dump of various state associated with the given application\n package name.  This call blocks while the dump is being performed, so should\n not be done on a UI thread.  The data will be written to the given file\n descriptor as text.\n \n Requires Manifest.permission.DUMP"
    },
    {
        "class": "android.app.ActivityManager",
        "api": "killBackgroundProcesses",
        "permissionText": "Have the system immediately kill all background processes associated\n with the given package.  This is the same as the kernel killing those\n processes to reclaim memory; the system will take care of restarting\n these processes in the future as needed.\n\n \n Requires Manifest.permission.KILL_BACKGROUND_PROCESSES"
    },
    {
        "class": "android.app.ActivityManager",
        "api": "moveTaskToFront",
        "permissionText": "Ask that the task associated with a given task ID be moved to the\n front of the stack, so it is now visible to the user.\n\n \n Requires Manifest.permission.REORDER_TASKS"
    },
    {
        "class": "android.app.ActivityManager",
        "api": "moveTaskToFront",
        "permissionText": "Equivalent to calling moveTaskToFront(int, int, android.os.Bundle)\n with a null options argument.\n\n \n Requires Manifest.permission.REORDER_TASKS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "PACKAGE_NAME_KEY_LEGACY_VISIBLE",
        "permissionText": "Target API level below Build.VERSION_CODES.O and have\n deprecated Manifest.permission.GET_ACCOUNTS permission.\n \n  Have Manifest.permission.GET_ACCOUNTS_PRIVILEGED permission. \n  Have the same signature as authenticator. \n  Have Manifest.permission.READ_CONTACTS permission and\n account type may be associated with contacts data - (verified by\n Manifest.permission.WRITE_CONTACTS permission check for the authenticator)."
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "addAccount",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "addAccountExplicitly",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs\n for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "addOnAccountsUpdatedListener",
        "permissionText": "Adds an OnAccountsUpdateListener to this instance of the AccountManager. This\n listener will be notified whenever user or AbstractAcccountAuthenticator made changes to\n accounts of any type related to the caller. This method is equivalent to\n addOnAccountsUpdatedListener(listener, handler, updateImmediately, null)\n\n \n Requires Manifest.permission.GET_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "blockingGetAuthToken",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n USE_CREDENTIALS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.USE_CREDENTIALS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "clearPassword",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "confirmCredentials",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs\n for this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "editProperties",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs\n for this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAccounts",
        "permissionText": "It is safe to call this method from the main thread.\n\n \n Requires Manifest.permission.GET_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAccountsByType",
        "permissionText": "Caller targeting API level Build.VERSION_CODES.O and above, will get list\n of accounts made visible to it by user\n (see newChooseAccountIntent(android.accounts.Account, java.util.List, java.lang.String[], java.lang.String, java.lang.String, java.lang.String[], android.os.Bundle)) or AbstractAcccountAuthenticator\n using setAccountVisibility(Account, String, int).\n Manifest.permission.GET_ACCOUNTS permission is not used."
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAccountsByTypeAndFeatures",
        "permissionText": "Caller targeting API level Build.VERSION_CODES.O and above, will get list\n of accounts made visible to it by user\n (see newChooseAccountIntent(android.accounts.Account, java.util.List, java.lang.String[], java.lang.String, java.lang.String, java.lang.String[], android.os.Bundle)) or AbstractAcccountAuthenticator\n using setAccountVisibility(Account, String, int).\n Manifest.permission.GET_ACCOUNTS permission is not used."
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAuthToken",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n USE_CREDENTIALS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.USE_CREDENTIALS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAuthToken",
        "permissionText": "This method may be called from any thread, but the returned\n AccountManagerFuture must not be used on the main thread.\n\n \n Requires android.Manifest.permission.USE_CREDENTIALS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAuthToken",
        "permissionText": "This method may be called from any thread, but the returned\n AccountManagerFuture must not be used on the main thread.\n\n \n Requires android.Manifest.permission.USE_CREDENTIALS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getAuthTokenByFeatures",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before, MANAGE_ACCOUNTS\n permission is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getPassword",
        "permissionText": "NOTE: If targeting your app to work on API level\n Build.VERSION_CODES.LOLLIPOP_MR1 and before, AUTHENTICATE_ACCOUNTS\n permission is needed for those platforms. See docs for this function in API level\n Build.VERSION_CODES.LOLLIPOP_MR1.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "getUserData",
        "permissionText": "NOTE: If targeting your app to work on API level\n Build.VERSION_CODES.LOLLIPOP_MR1 and before, AUTHENTICATE_ACCOUNTS\n permission is needed for those platforms. See docs for this function in API level\n Build.VERSION_CODES.LOLLIPOP_MR1.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "hasFeatures",
        "permissionText": "If caller target API level is below Build.VERSION_CODES.O, it is\n required to hold the permission Manifest.permission.GET_ACCOUNTS or have a\n signature match with the AbstractAccountAuthenticator that manages the account."
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "invalidateAuthToken",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS or USE_CREDENTIALS permission is needed for those\n platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS or android.Manifest.permission.USE_CREDENTIALS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "notifyAccountAuthenticated",
        "permissionText": "This method requires the caller to have a signature match with the\n authenticator that owns the specified account.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "peekAuthToken",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "removeAccount",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "removeAccount",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "removeAccountExplicitly",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "renameAccount",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "setAuthToken",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "setPassword",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "setUserData",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n is needed for those platforms. See docs for this function in API level 22.\n\n \n Requires android.Manifest.permission.AUTHENTICATE_ACCOUNTS"
    },
    {
        "class": "android.accounts.AccountManager",
        "api": "updateCredentials",
        "permissionText": "NOTE: If targeting your app to work on API level 22 and before,\n MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n this function in API level 22.\n\n \n Requires android.Manifest.permission.MANAGE_ACCOUNTS"
    },
    {
        "class": "android.accessibilityservice.AccessibilityService",
        "api": "getFingerprintGestureController",
        "permissionText": "Get the controller for fingerprint gestures. This feature requires AccessibilityServiceInfo#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES.\n\nNote:  The service must be connected before this method is called.\n\n \n Requires Manifest.permission.USE_FINGERPRINT"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getActiveNetwork",
        "permissionText": "Returns a Network object corresponding to the currently active\n default data network.  In the event that the current active default data\n network disconnects, the returned Network object will no longer\n be usable.  This will return null when there is no default\n network.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getActiveNetworkInfo",
        "permissionText": "Returns details about the currently active default data network. When\n connected, this network is the default route for outgoing connections.\n You should always check NetworkInfo#isConnected() before initiating\n network traffic. This may return null when there is no default\n network.\n Note that if the default network is a VPN, this method will return the\n NetworkInfo for one of its underlying networks instead, or null if the\n VPN agent did not specify any. Apps interested in learning about VPNs\n should use getNetworkInfo(android.net.Network) instead.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getAllNetworkInfo",
        "permissionText": "Returns connection status information about all network\n types supported by the device.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getAllNetworks",
        "permissionText": "Returns an array of all Network currently tracked by the\n framework.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getLinkProperties",
        "permissionText": "Get the LinkProperties for the given Network.  This\n will return null if the network is unknown.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getMultipathPreference",
        "permissionText": "Provides a hint to the calling application on whether it is desirable to use the\n multinetwork APIs (e.g., Network#openConnection, Network#bindSocket, etc.)\n for multipath data transfer on this network when it is not the system default network.\n Applications desiring to use multipath network protocols should call this method before\n each such operation.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getNetworkCapabilities",
        "permissionText": "Get the NetworkCapabilities for the given Network.  This\n will return null if the network is unknown.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getNetworkInfo",
        "permissionText": "Returns connection status information about a particular\n network type.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getNetworkInfo",
        "permissionText": "Returns connection status information about a particular\n Network.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "getNetworkPreference",
        "permissionText": "Retrieves the current preferred network type.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "isActiveNetworkMetered",
        "permissionText": "Returns if the currently active data network is metered. A network is\n classified as metered when the user is sensitive to heavy data usage on\n that connection due to monetary costs, data limitations or\n battery/performance issues. You should check this before doing large\n data transfers, and warn the user or delay the operation until another\n network is available.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "registerDefaultNetworkCallback",
        "permissionText": "Registers to receive notifications about changes in the system default network. The callbacks\n will continue to be called until either the application exits or\n unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback) is called.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "registerDefaultNetworkCallback",
        "permissionText": "Registers to receive notifications about changes in the system default network. The callbacks\n will continue to be called until either the application exits or\n unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback) is called.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "registerNetworkCallback",
        "permissionText": "Registers to receive notifications about all networks which satisfy the given\n NetworkRequest.  The callbacks will continue to be called until\n either the application exits or unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback) is\n called.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "registerNetworkCallback",
        "permissionText": "The request may be released normally by calling\n unregisterNetworkCallback(android.app.PendingIntent).\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "registerNetworkCallback",
        "permissionText": "Registers to receive notifications about all networks which satisfy the given\n NetworkRequest.  The callbacks will continue to be called until\n either the application exits or unregisterNetworkCallback(android.net.ConnectivityManager.NetworkCallback) is\n called.\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE"
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "requestNetwork",
        "permissionText": "This method requires the caller to hold either the\n Manifest.permission.CHANGE_NETWORK_STATE permission\n or the ability to modify system settings as determined by\n Settings.System.canWrite(Context)."
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "requestNetwork",
        "permissionText": "This method requires the caller to hold either the\n Manifest.permission.CHANGE_NETWORK_STATE permission\n or the ability to modify system settings as determined by\n Settings.System.canWrite(Context)."
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "requestNetwork",
        "permissionText": "This method requires the caller to hold either the\n Manifest.permission.CHANGE_NETWORK_STATE permission\n or the ability to modify system settings as determined by\n Settings.System.canWrite(Context)."
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "requestNetwork",
        "permissionText": "This method requires the caller to hold either the\n Manifest.permission.CHANGE_NETWORK_STATE permission\n or the ability to modify system settings as determined by\n Settings.System.canWrite(Context)."
    },
    {
        "class": "android.net.ConnectivityManager",
        "api": "requestNetwork",
        "permissionText": "This method requires the caller to hold either the\n Manifest.permission.CHANGE_NETWORK_STATE permission\n or the ability to modify system settings as determined by\n Settings.System.canWrite(Context)."
    },
    {
        "class": "android.telecom.Connection.VideoProvider",
        "api": "SESSION_EVENT_CAMERA_PERMISSION_ERROR",
        "permissionText": "Session event raised by Telecom when\n InCallService.VideoCall.setCamera(String) is called and the\n caller does not have the necessary Manifest.permission.CAMERA permission."
    },
    {
        "class": "android.companion.CompanionDeviceManager",
        "api": "associate",
        "permissionText": "If your app needs to be excluded from battery optimizations (run in the background)\n or to have unrestricted data access (use data in the background) you can declare that\n you use the Manifest.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND and Manifest.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND respectively. Note that these\n special capabilities have a negative effect on the device's battery and user's data\n usage, therefore you should requested them when absolutely necessary."
    },
    {
        "class": "android.nfc.cardemulation.CardEmulation",
        "api": "isDefaultServiceForAid",
        "permissionText": "Returns\n      \n        boolean\n        whether the service is the default handler for the specified AID\n\n Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.cardemulation.CardEmulation",
        "api": "isDefaultServiceForCategory",
        "permissionText": "Returns\n      \n        boolean\n        whether service is currently the default service for the category.\n\n Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.cardemulation.CardEmulation",
        "api": "setOffHostForService",
        "permissionText": "Registeration will be successful only if the Secure Element\n exists on the device.\n\n \n Requires Manifest.permission.NFC"
    },
    {
        "class": "android.nfc.cardemulation.CardEmulation",
        "api": "unsetOffHostForService",
        "permissionText": "Note that you can only unset off-host SE for a service that\n is running under the same UID as the caller of this API. Typically\n this means you need to call this from the same\n package as the service itself, though UIDs can also\n be shared between packages using shared UIDs.\n\n \n Requires Manifest.permission.NFC"
    },
    {
        "class": "android.hardware.camera2.CaptureResult",
        "api": "LENS_DISTORTION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CaptureResult",
        "api": "LENS_INTRINSIC_CALIBRATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CaptureResult",
        "api": "LENS_POSE_ROTATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CaptureResult",
        "api": "LENS_POSE_TRANSLATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CaptureResult",
        "api": "LENS_RADIAL_DISTORTION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraManager",
        "api": "openCamera",
        "permissionText": "Manifest.permission.CAMERA"
    },
    {
        "class": "android.hardware.camera2.CameraManager",
        "api": "openCamera",
        "permissionText": "Manifest.permission.CAMERA"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_DISTORTION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_INFO_HYPERFOCAL_DISTANCE",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_INFO_MINIMUM_FOCUS_DISTANCE",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_INTRINSIC_CALIBRATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_POSE_REFERENCE",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_POSE_ROTATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_POSE_TRANSLATION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "LENS_RADIAL_DISTORTION",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_CALIBRATION_TRANSFORM1",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_CALIBRATION_TRANSFORM2",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_COLOR_TRANSFORM1",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_COLOR_TRANSFORM2",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_FORWARD_MATRIX1",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_FORWARD_MATRIX2",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_REFERENCE_ILLUMINANT1",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "SENSOR_REFERENCE_ILLUMINANT2",
        "permissionText": "Permission Manifest.permission.CAMERA is needed to access this property"
    },
    {
        "class": "android.hardware.camera2.CameraCharacteristics",
        "api": "getKeysNeedingPermission",
        "permissionText": "Returns a subset of the list returned by getKeys() with all keys that\n require camera clients to obtain the Manifest.permission.CAMERA permission."
    },
    {
        "class": "android.os.Build.VERSION_CODES",
        "api": "DONUT",
        "permissionText": "They must explicitly request the\n Manifest.permission.WRITE_EXTERNAL_STORAGE permission to be\n able to modify the contents of the SD card.  (Apps targeting\n earlier versions will always request the permission.)\n  They must explicitly request the\n Manifest.permission.READ_PHONE_STATE permission to be\n able to be able to retrieve phone state info.  (Apps targeting\n earlier versions will always request the permission.)\n  They are assumed to support different screen densities and\n sizes.  (Apps targeting earlier versions are assumed to only support\n medium density normal size screens unless otherwise indicated).\n They can still explicitly specify screen support either way with the\n supports-screens manifest tag.\n  TabHost will use the new dark tab\n background design."
    },
    {
        "class": "android.os.Build.VERSION_CODES",
        "api": "JELLY_BEAN",
        "permissionText": "You must explicitly request the Manifest.permission.READ_CALL_LOG\n and/or Manifest.permission.WRITE_CALL_LOG permissions;\n access to the call log is no longer implicitly provided through\n Manifest.permission.READ_CONTACTS and\n Manifest.permission.WRITE_CONTACTS.\n  RemoteViews will throw an exception if\n setting an onClick handler for views being generated by a\n RemoteViewsService for a collection container;\n previously this just resulted in a warning log message.\n  New ActionBar policy for embedded tabs:\n embedded tabs are now always stacked in the action bar when in portrait\n mode, regardless of the size of the screen.\n  WebSettings.setAllowFileAccessFromFileURLs and\n WebSettings.setAllowUniversalAccessFromFileURLs default to false.\n  Calls to PackageManager.setComponentEnabledSetting will now throw an\n IllegalArgumentException if the given component class name does not\n exist in the application's manifest.\n  NfcAdapter.setNdefPushMessage,\n NfcAdapter.setNdefPushMessageCallback and\n NfcAdapter.setOnNdefPushCompleteCallback will throw\n IllegalStateException if called after the Activity has been destroyed.\n  Accessibility services must require the new\n Manifest.permission.BIND_ACCESSIBILITY_SERVICE permission or\n they will not be available for use.\n  AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS must be set\n for unimportant views to be included in queries."
    },
    {
        "class": "android.os.Build.VERSION_CODES",
        "api": "KITKAT",
        "permissionText": "The default result of\n PreferenceActivity.isValueFragment becomes false instead of true.\n  In WebView, apps targeting earlier versions will have\n JS URLs evaluated directly and any result of the evaluation will not replace\n the current page content.  Apps targetting KITKAT or later that load a JS URL will\n have the result of that URL replace the content of the current page\n  AlarmManager.set becomes interpreted as\n an inexact value, to give the system more flexibility in scheduling alarms.\n  Context.getSharedPreferences no longer allows a null name.\n  RelativeLayout changes to compute wrapped content\n margins correctly.\n  ActionBar's window content overlay is allowed to be\n drawn.\n The Manifest.permission.READ_EXTERNAL_STORAGE\n permission is now always enforced.\n Access to package-specific external storage directories belonging\n to the calling app no longer requires the\n Manifest.permission.READ_EXTERNAL_STORAGE or\n Manifest.permission.WRITE_EXTERNAL_STORAGE\n permissions."
    },
    {
        "class": "android.os.Build.VERSION_CODES",
        "api": "LOLLIPOP",
        "permissionText": "Context.bindService now\n requires an explicit Intent, and will throw an exception if given an implicit\n Intent.\n  Notification.Builder will\n not have the colors of their various notification elements adjusted to better\n match the new material design look.\n  Message will validate that a message is not currently\n in use when it is recycled.\n  Hardware accelerated drawing in windows will be enabled automatically\n in most places.\n  Spinner throws an exception if attaching an\n adapter with more than one item type.\n  If the app is a launcher, the launcher will be available to the user\n even when they are using corporate profiles (which requires that the app\n use LauncherApps to correctly populate its\n apps UI).\n  Calling Service.stopForeground\n with removeNotification false will modify the still posted notification so that\n it is no longer forced to be ongoing.\n  A DreamService must require the\n Manifest.permission.BIND_DREAM_SERVICE permission to be usable."
    },
    {
        "class": "android.os.Build.VERSION_CODES",
        "api": "P",
        "permissionText": "Service.startForeground requires\n that apps hold the permission\n Manifest.permission.FOREGROUND_SERVICE.\n LinearLayout will always remeasure weighted children,\n even if there is no excess space."
    },
    {
        "class": "android.telephony.euicc.EuiccManager",
        "api": "deleteSubscription",
        "permissionText": "Requires that the calling app has carrier privileges according to the metadata of the\n profile to be deleted, or the\n android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS permission.\n\n \n Requires android.Manifest.permission.WRITE_EMBEDDED_SUBSCRIPTIONS"
    },
    {
        "class": "android.telephony.euicc.EuiccManager",
        "api": "downloadSubscription",
        "permissionText": "On a multi-active SIM device, requires the\n android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS permission, or a calling app\n only if the targeted eUICC does not currently have an active subscription or the calling app\n is authorized to manage the active subscription on the target eUICC, and the calling app is\n authorized to manage any active subscription on any SIM. Without it, an\n EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR will be returned in the callback\n intent to prompt the user to accept the download. The caller should also be authorized to\n manage the subscription to be downloaded.\n\n \n Requires android.Manifest.permission.WRITE_EMBEDDED_SUBSCRIPTIONS"
    },
    {
        "class": "android.telephony.euicc.EuiccManager",
        "api": "switchToSubscription",
        "permissionText": "On a multi-active SIM device, requires the\n android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS permission, or a calling app\n  only if the targeted eUICC does not currently have an active subscription or the calling app\n is authorized to manage the active subscription on the target eUICC, and the calling app is\n authorized to manage any active subscription on any SIM. Without it, an\n EMBEDDED_SUBSCRIPTION_RESULT_RESOLVABLE_ERROR will be returned in the callback\n intent to prompt the user to accept the download. The caller should also be authorized to\n manage the subscription to be enabled.\n\n \n Requires android.Manifest.permission.WRITE_EMBEDDED_SUBSCRIPTIONS"
    },
    {
        "class": "android.telephony.euicc.EuiccManager",
        "api": "updateSubscriptionNickname",
        "permissionText": "Requires that the calling app has carrier privileges according to the metadata of the\n profile to be updated, or the\n android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS permission.\n\n \n Requires android.Manifest.permission.WRITE_EMBEDDED_SUBSCRIPTIONS"
    },
    {
        "class": "android.os.Environment",
        "api": "getExternalStorageDirectory",
        "permissionText": "Writing to this path requires the\n Manifest.permission.WRITE_EXTERNAL_STORAGE permission,\n and starting in Build.VERSION_CODES.KITKAT, read\n access requires the\n Manifest.permission.READ_EXTERNAL_STORAGE permission,\n which is automatically granted if you hold the write permission."
    },
    {
        "class": "android.os.DropBoxManager",
        "api": "ACTION_DROPBOX_ENTRY_ADDED",
        "permissionText": "Broadcast Action: This is broadcast when a new entry is added in the dropbox.\n You must hold the Manifest.permission.READ_LOGS permission\n in order to receive this broadcast. This broadcast can be rate limited for low priority\n entries"
    },
    {
        "class": "android.os.DropBoxManager",
        "api": "getNextEntry",
        "permissionText": "Gets the next entry from the drop box after the specified time.\n You must always call Entry#close() on the return value!\n\n \n Requires Manifest.permission.READ_LOGS and Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "ACTION_DEVICE_ADMIN_SERVICE",
        "permissionText": "Service action: Action for a service that device owner and profile owner can optionally\n own.  If a device owner or a profile owner has such a service, the system tries to keep\n a bound connection to it, in order to keep their process always running.\n The service must be protected with the Manifest.permission.BIND_DEVICE_ADMIN\n permission."
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "EXTRA_PASSWORD_COMPLEXITY",
        "permissionText": "If an invalid value is used, it will be treated as PASSWORD_COMPLEXITY_NONE.\n \n \n Requires Manifest.permission.REQUEST_PASSWORD_COMPLEXITY"
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_NAME",
        "permissionText": "This constant was deprecated\n      in API level 23.\n    Use EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME. This extra is still\n supported, but only if there is only one device admin receiver in the package that requires\n the permission Manifest.permission.BIND_DEVICE_ADMIN."
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "bindDeviceAdminServiceAsUser",
        "permissionText": "The service must be protected by Manifest.permission.BIND_DEVICE_ADMIN.\n Note that the Context used to obtain this\n DevicePolicyManager instance via Context#getSystemService(Class) will be used\n to bind to the Service."
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "getPasswordComplexity",
        "permissionText": "Note that when called from a profile which uses an unified challenge with its parent, the\n screen lock complexity of the parent will be returned. However, this API does not support\n explicitly querying the parent profile screen lock complexity via getParentProfileInstance(ComponentName).\n\n \n Requires Manifest.permission.REQUEST_PASSWORD_COMPLEXITY"
    },
    {
        "class": "android.app.admin.DevicePolicyManager",
        "api": "setAlwaysOnVpnPackage",
        "permissionText": "declare a VpnService in its manifest, guarded by\n         Manifest.permission.BIND_VPN_SERVICE;\n     target API 24 or above; and\n     not explicitly opt out of the feature through\n         VpnService.SERVICE_META_DATA_SUPPORTS_ALWAYS_ON."
    },
    {
        "class": "android.app.admin.DeviceAdminReceiver",
        "api": "ACTION_DEVICE_ADMIN_ENABLED",
        "permissionText": "This is the primary action that a device administrator must implement to be\n allowed to manage a device.  This will be set to the receiver\n when the user enables it for administration.  You will generally\n handle this in DeviceAdminReceiver#onEnabled(Context, Intent).  To be\n supported, the receiver must also require the\n Manifest.permission.BIND_DEVICE_ADMIN permission so\n that other applications can not abuse it."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "clearWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getExternalCacheDir",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getExternalCacheDirs",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getExternalFilesDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getExternalFilesDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getExternalMediaDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getObbDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "getObbDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "removeStickyBroadcast",
        "permissionText": "Remove the data previously sent with sendStickyBroadcast(Intent),\n so that it is as if the sticky broadcast had never happened.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "removeStickyBroadcastAsUser",
        "permissionText": "You must hold the Manifest.permission.BROADCAST_STICKY\n permission in order to use this API.  If you do not hold that\n permission, SecurityException will be thrown.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendStickyBroadcast",
        "permissionText": "Perform a sendBroadcast(android.content.Intent) that is \"sticky,\" meaning the\n Intent you are sending stays around after the broadcast is complete,\n so that others can quickly retrieve that data through the return\n value of registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter).  In\n all other ways, this behaves the same as\n sendBroadcast(android.content.Intent).\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendStickyBroadcastAsUser",
        "permissionText": "Version of sendStickyBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendStickyOrderedBroadcast",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "sendStickyOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.ContextWrapper",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.Context",
        "api": "clearWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.Context",
        "api": "getExternalCacheDir",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getExternalCacheDirs",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getExternalFilesDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getExternalFilesDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getExternalMediaDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getObbDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "getObbDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.content.Context",
        "api": "removeStickyBroadcast",
        "permissionText": "Remove the data previously sent with sendStickyBroadcast(Intent),\n so that it is as if the sticky broadcast had never happened.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "removeStickyBroadcastAsUser",
        "permissionText": "You must hold the Manifest.permission.BROADCAST_STICKY\n permission in order to use this API.  If you do not hold that\n permission, SecurityException will be thrown.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.Context",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.Context",
        "api": "sendOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.content.Context",
        "api": "sendStickyBroadcast",
        "permissionText": "Perform a sendBroadcast(android.content.Intent) that is \"sticky,\" meaning the\n Intent you are sending stays around after the broadcast is complete,\n so that others can quickly retrieve that data through the return\n value of registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter).  In\n all other ways, this behaves the same as\n sendBroadcast(android.content.Intent).\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "sendStickyBroadcastAsUser",
        "permissionText": "Version of sendStickyBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "sendStickyOrderedBroadcast",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "sendStickyOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.content.Context",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.Context",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "addPeriodicSync",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "cancelSync",
        "permissionText": "If a periodic sync is specified, the caller must hold the permission\n     Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getCurrentSync",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_STATS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getCurrentSyncs",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_STATS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getIsSyncable",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getMasterSyncAutomatically",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getPeriodicSyncs",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "getSyncAutomatically",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "isSyncActive",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_STATS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "isSyncPending",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.READ_SYNC_STATS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "removePeriodicSync",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "setIsSyncable",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "setMasterSyncAutomatically",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.content.ContentResolver",
        "api": "setSyncAutomatically",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.WRITE_SYNC_SETTINGS."
    },
    {
        "class": "android.app.job.JobInfo.Builder",
        "api": "setPersisted",
        "permissionText": "Set whether or not to persist this job across device reboots.\n\n \n Requires Manifest.permission.RECEIVE_BOOT_COMPLETED"
    },
    {
        "class": "android.nfc.tech.IsoDep",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.IsoDep",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.IsoDep",
        "api": "getTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.IsoDep",
        "api": "setTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.IsoDep",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_BOOT_COMPLETED",
        "permissionText": "Broadcast Action: This is broadcast once, after the user has finished\n booting. It can be used to perform application-specific initialization,\n such as installing alarms. You must hold the\n Manifest.permission.RECEIVE_BOOT_COMPLETED permission in\n order to receive this broadcast."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_CALL",
        "permissionText": "Note: if you app targets M\n and above and declares as using the Manifest.permission.CALL_PHONE\n permission which is not granted, then attempting to use this action will\n result in a SecurityException."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_INSTALL_PACKAGE",
        "permissionText": "Note:If your app is targeting API level higher than 25 you\n need to hold Manifest.permission.REQUEST_INSTALL_PACKAGES\n in order to launch the application installer."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_LOCKED_BOOT_COMPLETED",
        "permissionText": "Broadcast Action: This is broadcast once, after the user has finished\n booting, but while still in the \"locked\" state. It can be used to perform\n application-specific initialization, such as installing alarms. You must\n hold the Manifest.permission.RECEIVE_BOOT_COMPLETED\n permission in order to receive this broadcast."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_NEW_OUTGOING_CALL",
        "permissionText": "You must hold the\n Manifest.permission.PROCESS_OUTGOING_CALLS\n permission to receive this Intent."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_UNINSTALL_PACKAGE",
        "permissionText": "Requires Manifest.permission.REQUEST_DELETE_PACKAGES\n since Build.VERSION_CODES#P."
    },
    {
        "class": "android.content.Intent",
        "api": "ACTION_VIEW_PERMISSION_USAGE",
        "permissionText": "Manifest.permission.START_VIEW_PERMISSION_USAGE"
    },
    {
        "class": "android.inputmethodservice.InputMethodService",
        "api": "android:imeExtractEnterAnimation",
        "permissionText": "Inherited methods\n\n\n\n\n  \n    From class\n      \n        \n          android.inputmethodservice.AbstractInputMethodService\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter fout, String[] args)\n      \n      \n        Implement this to handle Binder.dump()\n calls on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        KeyEvent.DispatcherState\n    \n  \n    \n      \n      getKeyDispatcherState()\n      \n      \n        Return the global KeyEvent.DispatcherState\n for used for processing events from the target application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodImpl\n    \n  \n    \n      \n      onCreateInputMethodInterface()\n      \n      \n        Called by the framework during initialization, when the InputMethod\n interface for this service needs to be created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodSessionImpl\n    \n  \n    \n      \n      onCreateInputMethodSessionInterface()\n      \n      \n        Called by the framework when a new InputMethodSession interface is\n needed for a new client of the input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onGenericMotionEvent(MotionEvent event)\n      \n      \n        Implement this to handle generic motion events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onTrackballEvent(MotionEvent event)\n      \n      \n        Implement this to handle trackball events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.app.Service\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter writer, String[] args)\n      \n      \n        Print the Service's state into the given stream.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Application\n    \n  \n    \n      \n      getApplication()\n      \n      \n        Return the application that owns this service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getForegroundServiceType()\n      \n      \n        If the service has become a foreground service by calling\n startForeground(int, android.app.Notification)\n or startForeground(int, android.app.Notification, int), getForegroundServiceType()\n returns the current foreground service type.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onCreate()\n      \n      \n        Called by the system when the service is first created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onDestroy()\n      \n      \n        Called by the system to notify a Service that it is no longer used and is being removed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onRebind(Intent intent)\n      \n      \n        Called when new clients have connected to the service, after it had\n previously been notified that all had disconnected in its\n onUnbind(Intent).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onStart(Intent intent, int startId)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Implement onStartCommand(android.content.Intent, int, int) instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      onStartCommand(Intent intent, int flags, int startId)\n      \n      \n        Called by the system every time a client explicitly starts the service by calling\n Context.startService(Intent), providing the arguments it supplied and a\n unique integer token representing the start request.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTaskRemoved(Intent rootIntent)\n      \n      \n        This is called if the service is currently running and the user has\n removed a task that comes from the service's application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onUnbind(Intent intent)\n      \n      \n        Called when all clients have disconnected from a particular interface\n published by the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification)\n      \n      \n        If your service is started (running through Context#startService(Intent)), then\n also make this service run in the foreground, supplying the ongoing\n notification to be shown to the user while in this state.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification, int foregroundServiceType)\n      \n      \n        An overloaded version of startForeground(int, android.app.Notification) with additional\n foregroundServiceType parameter.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(int flags)\n      \n      \n        Remove this service from foreground state, allowing it to be killed if\n more memory is needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(boolean removeNotification)\n      \n      \n        Synonym for stopForeground(int).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf()\n      \n      \n        Stop the service, if it was previously started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf(int startId)\n      \n      \n        Old version of stopSelfResult(int) that doesn't return a result.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        boolean\n    \n  \n    \n      \n      stopSelfResult(int startId)\n      \n      \n        Stop the service if the most recent time it was started was\n startId.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.ContextWrapper\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      attachBaseContext(Context base)\n      \n      \n        Set the base context for this ContextWrapper.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getBaseContext()\n      \n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String targetPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent name)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.Context\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createContextForSplit(String splitName)\n      \n      \n        Return a new Context object for the given split name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getColor(int id)\n      \n      \n        Returns a color associated with a particular resource ID and styled for\n the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        ColorStateList\n    \n  \n    \n      \n      getColorStateList(int id)\n      \n      \n        Returns a color state list associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Drawable\n    \n  \n    \n      \n      getDrawable(int id)\n      \n      \n        Returns a drawable object associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getOpPackageName()\n      \n      \n        Return the package name that should be used for AppOpsManager calls from\n this context, so that app ops manager's uid verification will work with the name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId, Object... formatArgs)\n      \n      \n        Returns a localized formatted string from the application's package's\n default string table, substituting the format arguments as defined in\n Formatter and String.format(String, Object...).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId)\n      \n      \n        Returns a localized string from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        <T>\n        T\n    \n  \n    \n      \n      getSystemService(Class<T> serviceClass)\n      \n      \n        Return the handle to a system-level service by class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        CharSequence\n    \n  \n    \n      \n      getText(int resId)\n      \n      \n        Return a localized, styled CharSequence from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int resid, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      registerComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Add a new ComponentCallbacks to the base application of the\n Context, which will be called at the same times as the ComponentCallbacks\n methods of activities and other components are called.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent service)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Remove a ComponentCallbacks object that was previously registered\n with registerComponentCallbacks(android.content.ComponentCallbacks).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          java.lang.Object\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      clone()\n      \n      \n        Creates and returns a copy of this object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      equals(Object obj)\n      \n      \n        Indicates whether some other object is \"equal to\" this one.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      finalize()\n      \n      \n        Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Class<?>\n    \n  \n    \n      \n      getClass()\n      \n      \n        Returns the runtime class of this Object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      hashCode()\n      \n      \n        Returns a hash code value for the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notify()\n      \n      \n        Wakes up a single thread that is waiting on this object's\n monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notifyAll()\n      \n      \n        Wakes up all threads that are waiting on this object's monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      toString()\n      \n      \n        Returns a string representation of the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout, int nanos)\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object, or\n some other thread interrupts the current thread, or a certain\n amount of real time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout)\n      \n      \n        Causes the current thread to wait until either another thread invokes the\n notify() method or the\n notifyAll() method for this object, or a\n specified amount of time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait()\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.view.KeyEvent.Callback\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyDown(int keyCode, KeyEvent event)\n      \n      \n        Called when a key down event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyLongPress(int keyCode, KeyEvent event)\n      \n      \n        Called when a long press has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyMultiple(int keyCode, int count, KeyEvent event)\n      \n      \n        Called when a user's interaction with an analog control, such as\n flinging a trackball, generates simulated down/up events for the same\n key multiple times in quick succession.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyUp(int keyCode, KeyEvent event)\n      \n      \n        Called when a key up event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks2\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage."
    },
    {
        "class": "android.inputmethodservice.InputMethodService",
        "api": "android:imeExtractExitAnimation",
        "permissionText": "Inherited methods\n\n\n\n\n  \n    From class\n      \n        \n          android.inputmethodservice.AbstractInputMethodService\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter fout, String[] args)\n      \n      \n        Implement this to handle Binder.dump()\n calls on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        KeyEvent.DispatcherState\n    \n  \n    \n      \n      getKeyDispatcherState()\n      \n      \n        Return the global KeyEvent.DispatcherState\n for used for processing events from the target application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodImpl\n    \n  \n    \n      \n      onCreateInputMethodInterface()\n      \n      \n        Called by the framework during initialization, when the InputMethod\n interface for this service needs to be created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodSessionImpl\n    \n  \n    \n      \n      onCreateInputMethodSessionInterface()\n      \n      \n        Called by the framework when a new InputMethodSession interface is\n needed for a new client of the input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onGenericMotionEvent(MotionEvent event)\n      \n      \n        Implement this to handle generic motion events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onTrackballEvent(MotionEvent event)\n      \n      \n        Implement this to handle trackball events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.app.Service\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter writer, String[] args)\n      \n      \n        Print the Service's state into the given stream.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Application\n    \n  \n    \n      \n      getApplication()\n      \n      \n        Return the application that owns this service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getForegroundServiceType()\n      \n      \n        If the service has become a foreground service by calling\n startForeground(int, android.app.Notification)\n or startForeground(int, android.app.Notification, int), getForegroundServiceType()\n returns the current foreground service type.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onCreate()\n      \n      \n        Called by the system when the service is first created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onDestroy()\n      \n      \n        Called by the system to notify a Service that it is no longer used and is being removed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onRebind(Intent intent)\n      \n      \n        Called when new clients have connected to the service, after it had\n previously been notified that all had disconnected in its\n onUnbind(Intent).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onStart(Intent intent, int startId)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Implement onStartCommand(android.content.Intent, int, int) instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      onStartCommand(Intent intent, int flags, int startId)\n      \n      \n        Called by the system every time a client explicitly starts the service by calling\n Context.startService(Intent), providing the arguments it supplied and a\n unique integer token representing the start request.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTaskRemoved(Intent rootIntent)\n      \n      \n        This is called if the service is currently running and the user has\n removed a task that comes from the service's application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onUnbind(Intent intent)\n      \n      \n        Called when all clients have disconnected from a particular interface\n published by the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification)\n      \n      \n        If your service is started (running through Context#startService(Intent)), then\n also make this service run in the foreground, supplying the ongoing\n notification to be shown to the user while in this state.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification, int foregroundServiceType)\n      \n      \n        An overloaded version of startForeground(int, android.app.Notification) with additional\n foregroundServiceType parameter.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(int flags)\n      \n      \n        Remove this service from foreground state, allowing it to be killed if\n more memory is needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(boolean removeNotification)\n      \n      \n        Synonym for stopForeground(int).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf()\n      \n      \n        Stop the service, if it was previously started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf(int startId)\n      \n      \n        Old version of stopSelfResult(int) that doesn't return a result.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        boolean\n    \n  \n    \n      \n      stopSelfResult(int startId)\n      \n      \n        Stop the service if the most recent time it was started was\n startId.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.ContextWrapper\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      attachBaseContext(Context base)\n      \n      \n        Set the base context for this ContextWrapper.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getBaseContext()\n      \n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String targetPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent name)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.Context\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createContextForSplit(String splitName)\n      \n      \n        Return a new Context object for the given split name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getColor(int id)\n      \n      \n        Returns a color associated with a particular resource ID and styled for\n the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        ColorStateList\n    \n  \n    \n      \n      getColorStateList(int id)\n      \n      \n        Returns a color state list associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Drawable\n    \n  \n    \n      \n      getDrawable(int id)\n      \n      \n        Returns a drawable object associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getOpPackageName()\n      \n      \n        Return the package name that should be used for AppOpsManager calls from\n this context, so that app ops manager's uid verification will work with the name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId, Object... formatArgs)\n      \n      \n        Returns a localized formatted string from the application's package's\n default string table, substituting the format arguments as defined in\n Formatter and String.format(String, Object...).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId)\n      \n      \n        Returns a localized string from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        <T>\n        T\n    \n  \n    \n      \n      getSystemService(Class<T> serviceClass)\n      \n      \n        Return the handle to a system-level service by class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        CharSequence\n    \n  \n    \n      \n      getText(int resId)\n      \n      \n        Return a localized, styled CharSequence from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int resid, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      registerComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Add a new ComponentCallbacks to the base application of the\n Context, which will be called at the same times as the ComponentCallbacks\n methods of activities and other components are called.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent service)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Remove a ComponentCallbacks object that was previously registered\n with registerComponentCallbacks(android.content.ComponentCallbacks).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          java.lang.Object\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      clone()\n      \n      \n        Creates and returns a copy of this object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      equals(Object obj)\n      \n      \n        Indicates whether some other object is \"equal to\" this one.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      finalize()\n      \n      \n        Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Class<?>\n    \n  \n    \n      \n      getClass()\n      \n      \n        Returns the runtime class of this Object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      hashCode()\n      \n      \n        Returns a hash code value for the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notify()\n      \n      \n        Wakes up a single thread that is waiting on this object's\n monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notifyAll()\n      \n      \n        Wakes up all threads that are waiting on this object's monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      toString()\n      \n      \n        Returns a string representation of the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout, int nanos)\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object, or\n some other thread interrupts the current thread, or a certain\n amount of real time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout)\n      \n      \n        Causes the current thread to wait until either another thread invokes the\n notify() method or the\n notifyAll() method for this object, or a\n specified amount of time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait()\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.view.KeyEvent.Callback\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyDown(int keyCode, KeyEvent event)\n      \n      \n        Called when a key down event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyLongPress(int keyCode, KeyEvent event)\n      \n      \n        Called when a long press has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyMultiple(int keyCode, int count, KeyEvent event)\n      \n      \n        Called when a user's interaction with an analog control, such as\n flinging a trackball, generates simulated down/up events for the same\n key multiple times in quick succession.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyUp(int keyCode, KeyEvent event)\n      \n      \n        Called when a key up event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks2\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage."
    },
    {
        "class": "android.inputmethodservice.InputMethodService",
        "api": "android:imeFullscreenBackground",
        "permissionText": "Inherited methods\n\n\n\n\n  \n    From class\n      \n        \n          android.inputmethodservice.AbstractInputMethodService\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter fout, String[] args)\n      \n      \n        Implement this to handle Binder.dump()\n calls on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        KeyEvent.DispatcherState\n    \n  \n    \n      \n      getKeyDispatcherState()\n      \n      \n        Return the global KeyEvent.DispatcherState\n for used for processing events from the target application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodImpl\n    \n  \n    \n      \n      onCreateInputMethodInterface()\n      \n      \n        Called by the framework during initialization, when the InputMethod\n interface for this service needs to be created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AbstractInputMethodService.AbstractInputMethodSessionImpl\n    \n  \n    \n      \n      onCreateInputMethodSessionInterface()\n      \n      \n        Called by the framework when a new InputMethodSession interface is\n needed for a new client of the input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onGenericMotionEvent(MotionEvent event)\n      \n      \n        Implement this to handle generic motion events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onTrackballEvent(MotionEvent event)\n      \n      \n        Implement this to handle trackball events on your input method.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.app.Service\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      dump(FileDescriptor fd, PrintWriter writer, String[] args)\n      \n      \n        Print the Service's state into the given stream.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Application\n    \n  \n    \n      \n      getApplication()\n      \n      \n        Return the application that owns this service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getForegroundServiceType()\n      \n      \n        If the service has become a foreground service by calling\n startForeground(int, android.app.Notification)\n or startForeground(int, android.app.Notification, int), getForegroundServiceType()\n returns the current foreground service type.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        IBinder\n    \n  \n    \n      \n      onBind(Intent intent)\n      \n      \n        Return the communication channel to the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onCreate()\n      \n      \n        Called by the system when the service is first created.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onDestroy()\n      \n      \n        Called by the system to notify a Service that it is no longer used and is being removed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onRebind(Intent intent)\n      \n      \n        Called when new clients have connected to the service, after it had\n previously been notified that all had disconnected in its\n onUnbind(Intent).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onStart(Intent intent, int startId)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Implement onStartCommand(android.content.Intent, int, int) instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      onStartCommand(Intent intent, int flags, int startId)\n      \n      \n        Called by the system every time a client explicitly starts the service by calling\n Context.startService(Intent), providing the arguments it supplied and a\n unique integer token representing the start request.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTaskRemoved(Intent rootIntent)\n      \n      \n        This is called if the service is currently running and the user has\n removed a task that comes from the service's application.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onUnbind(Intent intent)\n      \n      \n        Called when all clients have disconnected from a particular interface\n published by the service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification)\n      \n      \n        If your service is started (running through Context#startService(Intent)), then\n also make this service run in the foreground, supplying the ongoing\n notification to be shown to the user while in this state.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      startForeground(int id, Notification notification, int foregroundServiceType)\n      \n      \n        An overloaded version of startForeground(int, android.app.Notification) with additional\n foregroundServiceType parameter.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(int flags)\n      \n      \n        Remove this service from foreground state, allowing it to be killed if\n more memory is needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopForeground(boolean removeNotification)\n      \n      \n        Synonym for stopForeground(int).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf()\n      \n      \n        Stop the service, if it was previously started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      stopSelf(int startId)\n      \n      \n        Old version of stopSelfResult(int) that doesn't return a result.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        boolean\n    \n  \n    \n      \n      stopSelfResult(int startId)\n      \n      \n        Stop the service if the most recent time it was started was\n startId.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.ContextWrapper\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      attachBaseContext(Context base)\n      \n      \n        Set the base context for this ContextWrapper.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getBaseContext()\n      \n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String targetPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method is deprecated.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method is deprecated.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent name)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          android.content.Context\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindIsolatedService(Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)\n      \n      \n        Variation of bindService(Intent, ServiceConnection, int) that, in the specific case of isolated\n services, allows the caller to generate multiple instances of a service\n from a single component declaration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, int flags, Executor executor, ServiceConnection conn)\n      \n      \n        Same as bindService(android.content.Intent, android.content.ServiceConnection, int) with executor to control\n ServiceConnection callbacks.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      bindService(Intent service, ServiceConnection conn, int flags)\n      \n      \n        Connect to an application service, creating it if needed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC or you have been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingOrSelfUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process of an IPC or you has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingPermission(String permission)\n      \n      \n        Determine whether the calling process of an IPC you are handling has been\n granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkCallingUriPermission(Uri uri, int modeFlags)\n      \n      \n        Determine whether the calling process and user ID has been\n granted permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkPermission(String permission, int pid, int uid)\n      \n      \n        Determine whether the given permission is allowed for a particular\n process and user ID running in the system.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkSelfPermission(String permission)\n      \n      \n        Determine whether you have been granted a particular permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)\n      \n      \n        Check both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      checkUriPermission(Uri uri, int pid, int uid, int modeFlags)\n      \n      \n        Determine whether a particular process and user ID has been granted\n permission to access a specific URI.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      clearWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.clear() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createConfigurationContext(Configuration overrideConfiguration)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the given Configuration.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createContextForSplit(String splitName)\n      \n      \n        Return a new Context object for the given split name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDeviceProtectedStorageContext()\n      \n      \n        Return a new Context object for the current Context but whose storage\n APIs are backed by device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createDisplayContext(Display display)\n      \n      \n        Return a new Context object for the current Context but whose resources\n are adjusted to match the metrics of the given Display.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      createPackageContext(String packageName, int flags)\n      \n      \n        Return a new Context object for the given application name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      databaseList()\n      \n      \n        Returns an array of strings naming the private databases associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteDatabase(String name)\n      \n      \n        Delete an existing private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteFile(String name)\n      \n      \n        Delete the given private file associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      deleteSharedPreferences(String name)\n      \n      \n        Delete an existing shared preferences file.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfPermission(String permission, String message)\n      \n      \n        If neither you nor the calling process of an IPC you are\n handling has been granted a particular permission, throw a\n SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingOrSelfUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process of an IPC or you has not been\n granted permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingPermission(String permission, String message)\n      \n      \n        If the calling process of an IPC you are handling has not been\n granted a particular permission, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceCallingUriPermission(Uri uri, int modeFlags, String message)\n      \n      \n        If the calling process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforcePermission(String permission, int pid, int uid, String message)\n      \n      \n        If the given permission is not allowed for a particular process\n and user ID running in the system, throw a SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)\n      \n      \n        Enforce both a Uri and normal permission.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      enforceUriPermission(Uri uri, int pid, int uid, int modeFlags, String message)\n      \n      \n        If a particular process and user ID has not been granted\n permission to access a specific URI, throw SecurityException.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String[]\n    \n  \n    \n      \n      fileList()\n      \n      \n        Returns an array of strings naming the private files associated with\n this Context's application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Context\n    \n  \n    \n      \n      getApplicationContext()\n      \n      \n        Return the context of the single, global Application object of the\n current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ApplicationInfo\n    \n  \n    \n      \n      getApplicationInfo()\n      \n      \n        Return the full application info for this context's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        AssetManager\n    \n  \n    \n      \n      getAssets()\n      \n      \n        Returns an AssetManager instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ClassLoader\n    \n  \n    \n      \n      getClassLoader()\n      \n      \n        Return a class loader you can use to retrieve classes in this package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getCodeCacheDir()\n      \n      \n        Returns the absolute path to the application specific cache directory on\n the filesystem designed for storing cached code.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        int\n    \n  \n    \n      \n      getColor(int id)\n      \n      \n        Returns a color associated with a particular resource ID and styled for\n the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        ColorStateList\n    \n  \n    \n      \n      getColorStateList(int id)\n      \n      \n        Returns a color state list associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ContentResolver\n    \n  \n    \n      \n      getContentResolver()\n      \n      \n        Return a ContentResolver instance for your application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDataDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where all\n private files belonging to this app are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDatabasePath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a database created with\n openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getDir(String name, int mode)\n      \n      \n        Retrieve, creating if needed, a new directory in which the application\n can place its own custom data files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Drawable\n    \n  \n    \n      \n      getDrawable(int id)\n      \n      \n        Returns a drawable object associated with a particular resource ID and\n styled for the current theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalCacheDir()\n      \n      \n        Returns absolute path to application-specific directory on the primary\n shared/external storage device where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalCacheDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place cache\n files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getExternalFilesDir(String type)\n      \n      \n        Returns the absolute path to the directory on the primary shared/external\n storage device where the application can place persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalFilesDirs(String type)\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place\n persistent files it owns.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getExternalMediaDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application can place media\n files.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFileStreamPath(String name)\n      \n      \n        Returns the absolute path on the filesystem where a file created with\n openFileOutput(String, int) is stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem where files\n created with openFileOutput(String, int) are stored.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Executor\n    \n  \n    \n      \n      getMainExecutor()\n      \n      \n        Return an Executor that will run enqueued tasks on the main\n thread associated with this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Looper\n    \n  \n    \n      \n      getMainLooper()\n      \n      \n        Return the Looper for the main thread of the current process.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getNoBackupFilesDir()\n      \n      \n        Returns the absolute path to the directory on the filesystem similar to\n getFilesDir().\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File\n    \n  \n    \n      \n      getObbDir()\n      \n      \n        Return the primary shared/external storage directory where this\n application's OBB files (if there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        File[]\n    \n  \n    \n      \n      getObbDirs()\n      \n      \n        Returns absolute paths to application-specific directories on all\n shared/external storage devices where the application's OBB files (if\n there are any) can be found.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getOpPackageName()\n      \n      \n        Return the package name that should be used for AppOpsManager calls from\n this context, so that app ops manager's uid verification will work with the name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageCodePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        PackageManager\n    \n  \n    \n      \n      getPackageManager()\n      \n      \n        Return PackageManager instance to find global package information.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageName()\n      \n      \n        Return the name of this application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getPackageResourcePath()\n      \n      \n        Return the full path to this context's primary Android package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources\n    \n  \n    \n      \n      getResources()\n      \n      \n        Returns a Resources instance for the application's package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SharedPreferences\n    \n  \n    \n      \n      getSharedPreferences(String name, int mode)\n      \n      \n        Retrieve and hold the contents of the preferences file 'name', returning\n a SharedPreferences through which you can retrieve and modify its\n values.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId, Object... formatArgs)\n      \n      \n        Returns a localized formatted string from the application's package's\n default string table, substituting the format arguments as defined in\n Formatter and String.format(String, Object...).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        String\n    \n  \n    \n      \n      getString(int resId)\n      \n      \n        Returns a localized string from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        <T>\n        T\n    \n  \n    \n      \n      getSystemService(Class<T> serviceClass)\n      \n      \n        Return the handle to a system-level service by class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      getSystemService(String name)\n      \n      \n        Return the handle to a system-level service by name.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      getSystemServiceName(Class<?> serviceClass)\n      \n      \n        Gets the name of the system-level service that is represented by the specified class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        CharSequence\n    \n  \n    \n      \n      getText(int resId)\n      \n      \n        Return a localized, styled CharSequence from the application's package's\n default string table.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Resources.Theme\n    \n  \n    \n      \n      getTheme()\n      \n      \n        Return the Theme object associated with this Context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      getWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.get() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumHeight()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumHeight() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      getWallpaperDesiredMinimumWidth()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.getDesiredMinimumWidth() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      grantUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Grant permission to access a specific Uri to another package, regardless\n of whether that package has general permission to access the Uri's\n content provider.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isDeviceProtectedStorage()\n      \n      \n        Indicates if the storage APIs of this Context are backed by\n device-protected storage.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      isRestricted()\n      \n      \n        Indicates whether this Context is restricted.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveDatabaseFrom(Context sourceContext, String name)\n      \n      \n        Move an existing database file from the given source storage context to\n this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      moveSharedPreferencesFrom(Context sourceContext, String name)\n      \n      \n        Move an existing shared preferences file from the given source storage\n context to this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int resid, int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        TypedArray\n    \n  \n    \n      \n      obtainStyledAttributes(int[] attrs)\n      \n      \n        Retrieve styled attribute information in this Context's theme.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileInputStream\n    \n  \n    \n      \n      openFileInput(String name)\n      \n      \n        Open a private file associated with this Context's application package\n for reading.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        FileOutputStream\n    \n  \n    \n      \n      openFileOutput(String name, int mode)\n      \n      \n        Open a private file associated with this Context's application package\n for writing.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        SQLiteDatabase\n    \n  \n    \n      \n      openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory)\n      \n      \n        Open a new private SQLiteDatabase associated with this Context's\n application package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Drawable\n    \n  \n    \n      \n      peekWallpaper()\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.peek() instead.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      registerComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Add a new ComponentCallbacks to the base application of the\n Context, which will be called at the same times as the ComponentCallbacks\n methods of activities and other components are called.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter)\n      \n      \n        Register a BroadcastReceiver to be run in the main activity thread.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, int flags)\n      \n      \n        Register to receive intent broadcasts, with the receiver optionally being\n exposed to Instant Apps.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        Intent\n    \n  \n    \n      \n      registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)\n      \n      \n        Register to receive intent broadcasts, to run in the context of\n scheduler.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      removeStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(Uri uri, int modeFlags)\n      \n      \n        Remove all permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) or any other mechanism.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      revokeUriPermission(String toPackage, Uri uri, int modeFlags)\n      \n      \n        Remove permissions to access a particular content provider Uri\n that were previously added with grantUriPermission(String, Uri, int) for a specific target\n package.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, allowing\n an optional required permission to be enforced.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcast(Intent intent)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission)\n      \n      \n        Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of sendBroadcast(android.content.Intent) that allows you to\n receive data back from the broadcast.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcast(Intent intent, String receiverPermission)\n      \n      \n        Broadcast the given intent to all interested BroadcastReceivers, delivering\n them one at a time to allow more preferred receivers to consume the\n broadcast before it is delivered to less preferred receivers.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        Version of\n sendOrderedBroadcast(android.content.Intent, java.lang.String, android.content.BroadcastReceiver, android.os.Handler, int, java.lang.String, android.os.Bundle)\n that allows you to specify the\n user the broadcast will be sent to.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcast(Intent intent)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyBroadcastAsUser(Intent intent, UserHandle user)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcast(Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      sendStickyOrderedBroadcastAsUser(Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)\n      \n      \n        \n      This method was deprecated\n      in API level 21.\n    Sticky broadcasts should not be used.  They provide no security (anyone\n can access them), no protection (anyone can modify them), and many other problems.\n The recommended pattern is to use a non-sticky broadcast to report that something\n has changed, with another mechanism for apps to retrieve the current value whenever\n desired.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setTheme(int resid)\n      \n      \n        Set the base theme for this context.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(Bitmap bitmap)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      setWallpaper(InputStream data)\n      \n      \n        \n      This method was deprecated\n      in API level 15.\n    Use WallpaperManager.set() instead.\n This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents, Bundle options)\n      \n      \n        Launch multiple new activities.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivities(Intent[] intents)\n      \n      \n        Same as startActivities(android.content.Intent[], android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent)\n      \n      \n        Same as startActivity(android.content.Intent, android.os.Bundle) with no options\n specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startActivity(Intent intent, Bundle options)\n      \n      \n        Launch a new activity.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startForegroundService(Intent service)\n      \n      \n        Similar to startService(android.content.Intent), but with an implicit promise that the\n Service will call startForeground(int, android.app.Notification) once it begins running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      startInstrumentation(ComponentName className, String profileFile, Bundle arguments)\n      \n      \n        Start executing an Instrumentation class.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)\n      \n      \n        Same as startIntentSender(android.content.IntentSender, android.content.Intent, int, int, int, android.os.Bundle)\n with no options specified.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      startIntentSender(IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)\n      \n      \n        Like startActivity(android.content.Intent, android.os.Bundle), but taking a IntentSender\n to start.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        ComponentName\n    \n  \n    \n      \n      startService(Intent service)\n      \n      \n        Request that a given application service be started.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      stopService(Intent service)\n      \n      \n        Request that a given application service be stopped.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unbindService(ServiceConnection conn)\n      \n      \n        Disconnect from an application service.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterComponentCallbacks(ComponentCallbacks callback)\n      \n      \n        Remove a ComponentCallbacks object that was previously registered\n with registerComponentCallbacks(android.content.ComponentCallbacks).\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      unregisterReceiver(BroadcastReceiver receiver)\n      \n      \n        Unregister a previously registered BroadcastReceiver.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      updateServiceGroup(ServiceConnection conn, int group, int importance)\n      \n      \n        For a service previously bound with bindService(Intent, ServiceConnection, int) or a related method, change\n how the system manages that service's process in relation to other processes.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From class\n      \n        \n          java.lang.Object\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        Object\n    \n  \n    \n      \n      clone()\n      \n      \n        Creates and returns a copy of this object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      equals(Object obj)\n      \n      \n        Indicates whether some other object is \"equal to\" this one.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      finalize()\n      \n      \n        Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        Class<?>\n    \n  \n    \n      \n      getClass()\n      \n      \n        Returns the runtime class of this Object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        int\n    \n  \n    \n      \n      hashCode()\n      \n      \n        Returns a hash code value for the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notify()\n      \n      \n        Wakes up a single thread that is waiting on this object's\n monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      notifyAll()\n      \n      \n        Wakes up all threads that are waiting on this object's monitor.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        \n        \n        String\n    \n  \n    \n      \n      toString()\n      \n      \n        Returns a string representation of the object.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout, int nanos)\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object, or\n some other thread interrupts the current thread, or a certain\n amount of real time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait(long timeout)\n      \n      \n        Causes the current thread to wait until either another thread invokes the\n notify() method or the\n notifyAll() method for this object, or a\n specified amount of time has elapsed.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        \n        \n        \n        final\n        \n        void\n    \n  \n    \n      \n      wait()\n      \n      \n        Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.view.KeyEvent.Callback\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyDown(int keyCode, KeyEvent event)\n      \n      \n        Called when a key down event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyLongPress(int keyCode, KeyEvent event)\n      \n      \n        Called when a long press has occurred.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyMultiple(int keyCode, int count, KeyEvent event)\n      \n      \n        Called when a user's interaction with an analog control, such as\n flinging a trackball, generates simulated down/up events for the same\n key multiple times in quick succession.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        boolean\n    \n  \n    \n      \n      onKeyUp(int keyCode, KeyEvent event)\n      \n      \n        Called when a key up event has occurred.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks2\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onTrimMemory(int level)\n      \n      \n        Called when the operating system has determined that it is a good\n time for a process to trim unneeded memory from its process.\n        \n    \n\n      \n    \n  \n  \n\n\n    \n  \n\n\n\n\n\n\n  \n    From interface\n      \n        \n          android.content.ComponentCallbacks\n        \n      \n    \n    \n      \n\n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onConfigurationChanged(Configuration newConfig)\n      \n      \n        Called by the system when the device configuration changes while your\n component is running.\n        \n    \n\n      \n    \n  \n  \n\n  \n  \n  \n    \n        abstract\n        \n        \n        \n        \n        void\n    \n  \n    \n      \n      onLowMemory()\n      \n      \n        This is called when the overall system is running low on memory, and\n actively running processes should trim their memory usage."
    },
    {
        "class": "android.view.inputmethod.InputMethodManager",
        "api": "setCurrentInputMethodSubtype",
        "permissionText": "This method was deprecated\n      in API level 29.\n    If the calling process is an IME, use\n             InputMethodService#switchInputMethod(String, InputMethodSubtype), which\n             does not require any permission as long as the caller is the current IME.\n             If the calling process is some privileged app that already has\n             Manifest.permission.WRITE_SECURE_SETTINGS permission, just\n             directly update Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE."
    },
    {
        "class": "android.view.inputmethod.InputMethodManager",
        "api": "setInputMethod",
        "permissionText": "On Android Build.VERSION_CODES#Q and later devices, the undocumented behavior that\n token can be null when the caller has\n Manifest.permission.WRITE_SECURE_SETTINGS is deprecated. Instead, update\n Settings.Secure.DEFAULT_INPUT_METHOD and\n Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE directly."
    },
    {
        "class": "android.view.inputmethod.InputMethodManager",
        "api": "setInputMethodAndSubtype",
        "permissionText": "On Android Build.VERSION_CODES#Q and later devices, token cannot be\n null even with Manifest.permission.WRITE_SECURE_SETTINGS. Instead,\n update Settings.Secure.DEFAULT_INPUT_METHOD and\n Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE directly."
    },
    {
        "class": "android.view.inputmethod.InputMethod",
        "api": "SERVICE_INTERFACE",
        "permissionText": "This is the interface name that a service implementing an input\n method should say that it supports -- that is, this is the action it\n uses for its intent filter.\n To be supported, the service must also require the\n Manifest.permission.BIND_INPUT_METHOD permission so\n that other applications can not abuse it."
    },
    {
        "class": "android.net.wifi.aware.IdentityChangedListener",
        "api": "onIdentityChanged",
        "permissionText": "Parameters\n      \n        mac\n        \n          byte: The MAC address of the Aware discovery interface. The application must have the\n Manifest.permission.ACCESS_FINE_LOCATION to get the actual MAC address,\n            otherwise all 0's will be provided."
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentAllowEnterTransitionOverlap",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentAllowReturnTransitionOverlap",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentEnterTransition",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentExitTransition",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentReenterTransition",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentSharedElementEnterTransition",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "android:fragmentSharedElementReturnTransition",
        "permissionText": "requestPermissions\n    \n      \n    Added in API level 23\n  Deprecated in\n    API level\n      28\n  \n      \n  \n\n    \npublic final void requestPermissions (String[] permissions, \n                int requestCode)\n    \n    \n\n    \n  Requests permissions to be granted to this application. These permissions\n must be requested in your manifest, they should not be granted to your app,\n and they should have protection level #PROTECTION_DANGEROUS dangerous, regardless whether they are declared by\n the platform or a third-party app.\n \n Normal permissions PermissionInfo.PROTECTION_NORMAL\n are granted at install time if requested in the manifest. Signature permissions\n PermissionInfo.PROTECTION_SIGNATURE are granted at\n install time if requested in the manifest and the signature of your app matches\n the signature of the app declaring the permissions.\n \n \n If your app does not have the requested permissions the user will be presented\n with UI for accepting them. After the user has accepted or rejected the\n requested permissions you will receive a callback on onRequestPermissionsResult(int, java.lang.String[], int[]) reporting whether the\n permissions were granted or not.\n \n \n Note that requesting a permission does not guarantee it will be granted and\n your app should be able to run without having this permission.\n \n \n This method may start an activity allowing the user to choose which permissions\n to grant and which to reject. Hence, you should be prepared that your activity\n may be paused and resumed. Further, granting some permissions may require\n a restart of you application. In such a case, the system will recreate the\n activity stack before delivering the result to onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n When checking whether you have a permission you should use Context.checkSelfPermission(String).\n \n \n Calling this API for permissions already granted to your app would show UI\n to the user to decide whether the app can still hold these permissions. This\n can be useful if the way your app uses data guarded by the permissions\n changes significantly.\n \n \n You cannot request a permission if your activity sets noHistory to\n true because in this case the activity would not receive\n result callbacks including onRequestPermissionsResult(int, java.lang.String[], int[]).\n \n \n A sample permissions request looks like this:\n \n \n private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }\n \n    \n    Parameters\n      \n        permissions\n        \n          String: The requested permissions. Must me non-null and not empty.\n This value must never be null.\n      \n      \n        requestCode\n        \n          int: Application specific request code to match with a result\n    reported to onRequestPermissionsResult(int, java.lang.String[], int[]).\n    Should be >= 0.\n      \n    \n  \n      See also:\n      onRequestPermissionsResult(int, String[], int[])Context.checkSelfPermission(String)"
    },
    {
        "class": "android.app.Fragment",
        "api": "requestPermissions",
        "permissionText": "private void showContacts() {\n     if (getActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS)\n             != PackageManager.PERMISSION_GRANTED) {\n         requestPermissions(new String[]{Manifest.permission.READ_CONTACTS},\n                 PERMISSIONS_REQUEST_READ_CONTACTS);\n     } else {\n         doShowContacts();\n     }\n }\n\n @Override\n public void onRequestPermissionsResult(int requestCode, String[] permissions,\n         int[] grantResults) {\n     if (requestCode == PERMISSIONS_REQUEST_READ_CONTACTS\n             && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n         doShowContacts();\n     }\n }"
    },
    {
        "class": "android.hardware.fingerprint.FingerprintManager",
        "api": "authenticate",
        "permissionText": "Request authentication of a crypto object. This call warms up the fingerprint hardware\n and starts scanning for a fingerprint. It terminates when\n AuthenticationCallback#onAuthenticationError(int, CharSequence) or\n AuthenticationCallback#onAuthenticationSucceeded(AuthenticationResult) is called, at\n which point the object is no longer valid. The operation can be canceled by using the\n provided cancel object.\n\n \n Requires Manifest.permission.USE_BIOMETRIC or Manifest.permission.USE_FINGERPRINT"
    },
    {
        "class": "android.hardware.fingerprint.FingerprintManager",
        "api": "hasEnrolledFingerprints",
        "permissionText": "Determine if there is at least one fingerprint enrolled.\n\n \n Requires Manifest.permission.USE_FINGERPRINT"
    },
    {
        "class": "android.hardware.fingerprint.FingerprintManager",
        "api": "isHardwareDetected",
        "permissionText": "Determine if fingerprint hardware is present and functional.\n\n \n Requires Manifest.permission.USE_FINGERPRINT"
    },
    {
        "class": "android.provider.MediaStore",
        "api": "ACTION_IMAGE_CAPTURE",
        "permissionText": "Note: if you app targets M and above\n and declares as using the Manifest.permission.CAMERA permission which\n is not granted, then attempting to use this action will result in a SecurityException."
    },
    {
        "class": "android.provider.MediaStore",
        "api": "ACTION_VIDEO_CAPTURE",
        "permissionText": "Note: if you app targets M and above\n and declares as using the Manifest.permission.CAMERA permission which\n is not granted, then atempting to use this action will result in a SecurityException."
    },
    {
        "class": "android.provider.MediaStore",
        "api": "setRequireOriginal",
        "permissionText": "If the original file contents cannot be provided, a\n UnsupportedOperationException will be thrown when the returned\n Uri is used, such as when the caller doesn't hold\n Manifest.permission.ACCESS_MEDIA_LOCATION."
    },
    {
        "class": "android.media.session.MediaSessionManager",
        "api": "addOnActiveSessionsChangedListener",
        "permissionText": "Add a listener to be notified when the list of active sessions\n changes.This requires the\n android.Manifest.permission.MEDIA_CONTENT_CONTROL permission be held by\n the calling app. You may also retrieve this list if your app is an\n enabled notification listener using the\n NotificationListenerService APIs, in which case you must pass the\n ComponentName of your enabled listener. Updates will be posted to\n the thread that registered the listener."
    },
    {
        "class": "android.media.session.MediaSessionManager",
        "api": "addOnActiveSessionsChangedListener",
        "permissionText": "Add a listener to be notified when the list of active sessions\n changes.This requires the\n android.Manifest.permission.MEDIA_CONTENT_CONTROL permission be held by\n the calling app. You may also retrieve this list if your app is an\n enabled notification listener using the\n NotificationListenerService APIs, in which case you must pass the\n ComponentName of your enabled listener. Updates will be posted to\n the handler specified or to the caller's thread if the handler is null."
    },
    {
        "class": "android.media.session.MediaSessionManager",
        "api": "getActiveSessions",
        "permissionText": "This requires the android.Manifest.permission.MEDIA_CONTENT_CONTROL\n permission be held by the calling app. You may also retrieve this list if\n your app is an enabled notification listener using the\n NotificationListenerService APIs, in which case you must pass the\n ComponentName of your enabled listener."
    },
    {
        "class": "android.media.session.MediaSessionManager",
        "api": "isTrustedForMediaControl",
        "permissionText": "An app is trusted if the app holds the android.Manifest.permission.MEDIA_CONTENT_CONTROL\n permission or has an enabled notification listener."
    },
    {
        "class": "android.media.MediaSession2Service",
        "api": "onUpdateNotification",
        "permissionText": "With the notification returned here, the service becomes foreground service when the playback\n is started. Apps must request the permission\n Manifest.permission.FOREGROUND_SERVICE in order to use this API. It becomes\n background service after the playback is stopped."
    },
    {
        "class": "android.media.MediaRecorder.AudioSource",
        "api": "REMOTE_SUBMIX",
        "permissionText": "Capturing the remote submix audio requires the\n Manifest.permission.CAPTURE_AUDIO_OUTPUT permission.\n This permission is reserved for use by system components and is not available to\n third-party applications."
    },
    {
        "class": "android.media.MediaRecorder.AudioSource",
        "api": "VOICE_CALL",
        "permissionText": "Capturing from VOICE_CALL source requires the\n Manifest.permission.CAPTURE_AUDIO_OUTPUT permission.\n This permission is reserved for use by system components and is not available to\n third-party applications."
    },
    {
        "class": "android.media.MediaRecorder.AudioSource",
        "api": "VOICE_DOWNLINK",
        "permissionText": "Capturing from VOICE_DOWNLINK source requires the\n Manifest.permission.CAPTURE_AUDIO_OUTPUT permission.\n This permission is reserved for use by system components and is not available to\n third-party applications."
    },
    {
        "class": "android.media.MediaRecorder.AudioSource",
        "api": "VOICE_UPLINK",
        "permissionText": "Capturing from VOICE_UPLINK source requires the\n Manifest.permission.CAPTURE_AUDIO_OUTPUT permission.\n This permission is reserved for use by system components and is not available to\n third-party applications."
    },
    {
        "class": "android.media.MediaPlayer",
        "api": "setWakeMode",
        "permissionText": "This function has the MediaPlayer access the low-level power manager\n service to control the device's power usage while playing is occurring.\n The parameter is a combination of PowerManager wake flags.\n Use of this method requires Manifest.permission.WAKE_LOCK\n permission.\n By default, no attempt is made to keep the device awake during playback."
    },
    {
        "class": "android.media.MediaExtractor",
        "api": "setDataSource",
        "permissionText": "Parameters\n      \n        context\n        \n          Context: the Context to use when resolving the Uri\n This value must never be null.\n      \n      \n        uri\n        \n          Uri: the Content URI of the data you want to extract from.\n\n When uri refers to a network file the\n Manifest.permission.INTERNET permission is required.\n\n This value must never be null.\n      \n      \n        headers\n        \n          Map: the headers to be sent together with the request for the data.\n        This can be null if no specific headers are to be sent with the\n        request.\n \n This value may be null."
    },
    {
        "class": "android.media.MediaExtractor",
        "api": "setDataSource",
        "permissionText": "Parameters\n      \n        path\n        \n          String: the path of the file, or the http URL of the stream\n\n When path refers to a local file, the file may actually be opened by a\n process other than the calling application.  This implies that the pathname\n should be an absolute path (as any other process runs with unspecified current working\n directory), and that the pathname should reference a world-readable file.\n As an alternative, the application could first open the file for reading,\n and then use the file descriptor form setDataSource(java.io.FileDescriptor).\n\n When path refers to a network file the\n Manifest.permission.INTERNET permission is required.\n \n This value must never be null."
    },
    {
        "class": "android.media.MediaExtractor",
        "api": "setDataSource",
        "permissionText": "Parameters\n      \n        path\n        \n          String: the path of the file, or the http URL\n\n When path refers to a network file the\n Manifest.permission.INTERNET permission is required.\n\n This value must never be null.\n      \n      \n        headers\n        \n          Map: the headers associated with the http request for the stream you want to play.\n        This can be null if no specific headers are to be sent with the\n        request.\n \n This value may be null."
    },
    {
        "class": "android.location.LocationManager",
        "api": "GPS_PROVIDER",
        "permissionText": "This provider determines location using\n satellites. Depending on conditions, this provider may take a while to return\n a location fix. Requires the permission\n Manifest.permission.ACCESS_FINE_LOCATION."
    },
    {
        "class": "android.location.LocationManager",
        "api": "PASSIVE_PROVIDER",
        "permissionText": "This provider can be used to passively receive location updates\n when other applications or services request them without actually requesting\n the locations yourself.  This provider will return locations generated by other\n providers.  You can query the Location#getProvider() method to determine\n the origin of the location update. Requires the permission\n Manifest.permission.ACCESS_FINE_LOCATION, although if the GPS is\n not enabled this provider might only return coarse fixes."
    },
    {
        "class": "android.location.LocationManager",
        "api": "addGpsStatusListener",
        "permissionText": "Adds a GPS status listener.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "addNmeaListener",
        "permissionText": "Adds an NMEA listener.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "addNmeaListener",
        "permissionText": "Adds an NMEA listener.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "addProximityAlert",
        "permissionText": "Before API version 17, this method could be used with\n Manifest.permission.ACCESS_FINE_LOCATION or\n Manifest.permission.ACCESS_COARSE_LOCATION.\n From API version 17 and onwards, this method requires\n Manifest.permission.ACCESS_FINE_LOCATION permission.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "getGpsStatus",
        "permissionText": "Retrieves information about the current status of the GPS engine.\n This should only be called from the GpsStatus.Listener#onGpsStatusChanged\n callback to ensure that the data is copied atomically.\n\n The caller may either pass in a GpsStatus object to set with the latest\n status information, or pass null to create a new GpsStatus object.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "getLastKnownLocation",
        "permissionText": "If the provider is currently disabled, null is returned.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "registerGnssMeasurementsCallback",
        "permissionText": "Registers a GPS Measurement callback.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "registerGnssMeasurementsCallback",
        "permissionText": "Registers a GPS Measurement callback.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "registerGnssNavigationMessageCallback",
        "permissionText": "Registers a GNSS Navigation Message callback.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "registerGnssStatusCallback",
        "permissionText": "Registers a GNSS status callback.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "registerGnssStatusCallback",
        "permissionText": "Registers a GNSS status callback.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "removeProximityAlert",
        "permissionText": "Before API version 17, this method could be used with\n Manifest.permission.ACCESS_FINE_LOCATION or\n Manifest.permission.ACCESS_COARSE_LOCATION.\n From API version 17 and onwards, this method requires\n Manifest.permission.ACCESS_FINE_LOCATION permission.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "removeUpdates",
        "permissionText": "Following this call, updates will no longer\n occur for this listener.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestLocationUpdates",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestLocationUpdates",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestLocationUpdates",
        "permissionText": "Prior to Jellybean, the minTime parameter was\n only a hint, and some location provider implementations ignored it.\n From Jellybean and onwards it is mandatory for Android compatible\n devices to observe both the minTime and minDistance parameters.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestLocationUpdates",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestLocationUpdates",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestSingleUpdate",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestSingleUpdate",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestSingleUpdate",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.location.LocationManager",
        "api": "requestSingleUpdate",
        "permissionText": "See requestLocationUpdates(long, float, android.location.Criteria, android.app.PendingIntent)\n for more detail on how to use this method.\n\n \n Requires Manifest.permission.ACCESS_COARSE_LOCATION or Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.app.KeyguardManager.KeyguardLock",
        "api": "disableKeyguard",
        "permissionText": "Disable the keyguard from showing.  If the keyguard is currently\n showing, hide it.  The keyguard will be prevented from showing again\n until reenableKeyguard() is called.\n\n A good place to call this is from Activity.onResume()\n\n Note: This call has no effect while any DevicePolicyManager\n is enabled that requires a password.\n\n \n Requires Manifest.permission.DISABLE_KEYGUARD"
    },
    {
        "class": "android.app.KeyguardManager.KeyguardLock",
        "api": "reenableKeyguard",
        "permissionText": "Reenable the keyguard.  The keyguard will reappear if the previous\n call to disableKeyguard() caused it to be hidden.\n\n A good place to call this is from Activity.onPause()\n\n Note: This call has no effect while any DevicePolicyManager\n is enabled that requires a password.\n\n \n Requires Manifest.permission.DISABLE_KEYGUARD"
    },
    {
        "class": "android.app.KeyguardManager",
        "api": "exitKeyguardSecurely",
        "permissionText": "Exit the keyguard securely.  The use case for this api is that, after\n disabling the keyguard, your app, which was granted permission to\n disable the keyguard and show a limited amount of information deemed\n safe without the user getting past the keyguard, needs to navigate to\n something that is not safe to view without getting past the keyguard.\n\n This will, if the keyguard is secure, bring up the unlock screen of\n the keyguard.\n\n \n Requires Manifest.permission.DISABLE_KEYGUARD"
    },
    {
        "class": "android.os.PowerManager",
        "api": "newWakeLock",
        "permissionText": "Although a wake lock can be created without special permissions,\n the Manifest.permission.WAKE_LOCK permission is\n required to actually acquire or release the wake lock that is returned."
    },
    {
        "class": "android.os.PowerManager",
        "api": "reboot",
        "permissionText": "Requires the Manifest.permission.REBOOT permission."
    },
    {
        "class": "android.telephony.PhoneStateListener",
        "api": "LISTEN_EMERGENCY_NUMBER_LIST",
        "permissionText": "Requires permission Manifest.permission.READ_PHONE_STATE or the calling\n app has carrier privileges (see TelephonyManager#hasCarrierPrivileges)."
    },
    {
        "class": "android.content.pm.PackageManager",
        "api": "canRequestPackageInstalls",
        "permissionText": "Checks whether the calling package is allowed to request package installs through package\n installer. Apps are encouraged to call this API before launching the package installer via\n intent Intent.ACTION_INSTALL_PACKAGE. Starting from Android O, the\n user can explicitly choose what external sources they trust to install apps on the device.\n If this API returns false, the install request will be blocked by the package installer and\n a dialog will be shown to the user with au option to launch settings to change their\n preference. An application must target Android O or higher and declare permission\n Manifest.permission.REQUEST_INSTALL_PACKAGES in order to use this API."
    },
    {
        "class": "android.content.pm.PackageInstaller",
        "api": "installExistingPackage",
        "permissionText": "This will\n PackageInstaller.SessionParams#setWhitelistedRestrictedPermissions(Set).\n\n \n Requires Manifest.permission.INSTALL_PACKAGES and android.Manifest.permission.INSTALL_EXISTING_PACKAGES"
    },
    {
        "class": "android.content.pm.PackageInstaller",
        "api": "uninstall",
        "permissionText": "Manifest.permission.DELETE_PACKAGES"
    },
    {
        "class": "android.content.pm.PackageInstaller",
        "api": "uninstall",
        "permissionText": "Manifest.permission.DELETE_PACKAGES"
    },
    {
        "class": "android.app.Notification.Builder",
        "api": "setFullScreenIntent",
        "permissionText": "Apps targeting Build.VERSION_CODES#Q and above will have to request\n a permission (Manifest.permission.USE_FULL_SCREEN_INTENT) in order to\n use full screen intents."
    },
    {
        "class": "android.nfc.tech.NfcV",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcV",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcV",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcF",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcF",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcF",
        "api": "getTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcF",
        "api": "setTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcF",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcBarcode",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcBarcode",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcB",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcB",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcB",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "ACTION_TRANSACTION_DETECTED",
        "permissionText": "This intent will only be sent if the application has requested permission for\n Manifest.permission.NFC_TRANSACTION_EVENT and if the application has the\n necessary access to Secure Element which witnessed the particular event.\n \n \n Requires Manifest.permission.NFC_TRANSACTION_EVENT"
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "disableForegroundDispatch",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "disableForegroundNdefPush",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "enableForegroundDispatch",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "enableForegroundNdefPush",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "setBeamPushUris",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "setBeamPushUrisCallback",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "setNdefPushMessage",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "setNdefPushMessageCallback",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.NfcAdapter",
        "api": "setOnNdefPushCompleteCallback",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcA",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcA",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcA",
        "api": "getTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcA",
        "api": "setTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NfcA",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NdefFormatable",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NdefFormatable",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NdefFormatable",
        "api": "format",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.NdefFormatable",
        "api": "formatReadOnly",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "getNdefMessage",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "isWritable",
        "permissionText": "Requires Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "makeReadOnly",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.Ndef",
        "api": "writeNdefMessage",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.test.mock.MockPackageManager",
        "api": "canRequestPackageInstalls",
        "permissionText": "Checks whether the calling package is allowed to request package installs through package\n installer. Apps are encouraged to call this API before launching the package installer via\n intent Intent.ACTION_INSTALL_PACKAGE. Starting from Android O, the\n user can explicitly choose what external sources they trust to install apps on the device.\n If this API returns false, the install request will be blocked by the package installer and\n a dialog will be shown to the user with an option to launch settings to change their\n preference. An application must target Android O or higher and declare permission\n Manifest.permission.REQUEST_INSTALL_PACKAGES in order to use this API."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "clearWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getExternalCacheDir",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getExternalCacheDirs",
        "permissionText": "The platform does not always monitor the space available in shared\n storage, and thus may not automatically delete these files. Apps should\n always manage the maximum space used in this location. Currently the only\n time files here will be deleted by the platform is when running on\n Build.VERSION_CODES.JELLY_BEAN_MR1 or later and\n Environment#isExternalStorageEmulated(File) returns true.\n Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getExternalFilesDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getExternalFilesDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getExternalMediaDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getObbDir",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "getObbDirs",
        "permissionText": "Shared storage may not always be available, since removable media can\n be ejected by the user. Media state can be checked using\n Environment#getExternalStorageState(File).\n There is no security enforced with these files. For example, any\n application holding\n Manifest.permission.WRITE_EXTERNAL_STORAGE can write to\n these files."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "removeStickyBroadcast",
        "permissionText": "Remove the data previously sent with sendStickyBroadcast(Intent),\n so that it is as if the sticky broadcast had never happened.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "removeStickyBroadcastAsUser",
        "permissionText": "You must hold the Manifest.permission.BROADCAST_STICKY\n permission in order to use this API.  If you do not hold that\n permission, SecurityException will be thrown.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendBroadcastAsUser",
        "permissionText": "Version of sendBroadcast(android.content.Intent, java.lang.String) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendStickyBroadcast",
        "permissionText": "Perform a sendBroadcast(android.content.Intent) that is \"sticky,\" meaning the\n Intent you are sending stays around after the broadcast is complete,\n so that others can quickly retrieve that data through the return\n value of registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter).  In\n all other ways, this behaves the same as\n sendBroadcast(android.content.Intent).\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendStickyBroadcastAsUser",
        "permissionText": "Version of sendStickyBroadcast(android.content.Intent) that allows you to specify the\n user the broadcast will be sent to.  This is not available to applications\n that are not pre-installed on the system image.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendStickyOrderedBroadcast",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "sendStickyOrderedBroadcastAsUser",
        "permissionText": "See BroadcastReceiver for more information on Intent broadcasts.\n\n \n Requires android.Manifest.permission.INTERACT_ACROSS_USERS and Manifest.permission.BROADCAST_STICKY"
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.test.mock.MockContext",
        "api": "setWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "getTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "readPages",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "setTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareUltralight",
        "api": "writePage",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "authenticateSectorWithKeyA",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "authenticateSectorWithKeyB",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "decrement",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "getTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "increment",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "readBlock",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "restore",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "setTimeout",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "transceive",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "transfer",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.MifareClassic",
        "api": "writeBlock",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.net.sip.SipAudioCall",
        "api": "setSpeakerMode",
        "permissionText": "Note: Requires the\n   Manifest.permission.MODIFY_AUDIO_SETTINGS permission."
    },
    {
        "class": "android.net.sip.SipAudioCall",
        "api": "startAudio",
        "permissionText": "Note: Requires the\n   Manifest.permission.RECORD_AUDIO,\n   Manifest.permission.ACCESS_WIFI_STATE and\n   Manifest.permission.WAKE_LOCK permissions."
    },
    {
        "class": "android.provider.Settings.System",
        "api": "canWrite",
        "permissionText": "Checks if the specified app can modify system settings. As of API\n level 23, an app cannot modify system settings unless it declares the\n Manifest.permission.WRITE_SETTINGS\n permission in its manifest, and the user specifically grants\n the app this capability. To prompt the user to grant this approval,\n the app must send an intent with the action Settings.ACTION_MANAGE_WRITE_SETTINGS, which causes\n the system to display a permission management screen."
    },
    {
        "class": "android.provider.Settings",
        "api": "ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
        "permissionText": "Activity Action: Ask the user to allow an app to ignore battery optimizations (that is,\n put them on the whitelist of apps shown by\n ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS).  For an app to use this, it also\n must hold the Manifest.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\n permission."
    },
    {
        "class": "android.provider.Settings",
        "api": "INTENT_CATEGORY_USAGE_ACCESS_CONFIG",
        "permissionText": "An activity that provides a user interface for adjusting usage access related\n preferences for its containing application. Optional but recommended for apps that\n use Manifest.permission.PACKAGE_USAGE_STATS."
    },
    {
        "class": "android.provider.Settings",
        "api": "canDrawOverlays",
        "permissionText": "Checks if the specified context can draw on top of other apps. As of API\n level 23, an app cannot draw on top of other apps unless it declares the\n Manifest.permission.SYSTEM_ALERT_WINDOW permission in its\n manifest, and the user specifically grants the app this\n capability. To prompt the user to grant this approval, the app must send an\n intent with the action\n ACTION_MANAGE_OVERLAY_PERMISSION, which\n causes the system to display a permission management screen."
    },
    {
        "class": "android.app.Service",
        "api": "startForeground",
        "permissionText": "Apps targeting API Build.VERSION_CODES.P or later must request\n the permission Manifest.permission.FOREGROUND_SERVICE in order to use\n this API."
    },
    {
        "class": "android.media.RingtoneManager",
        "api": "getCursor",
        "permissionText": "Note that the list of ringtones available will differ depending on whether the caller\n has the Manifest.permission.READ_EXTERNAL_STORAGE permission."
    },
    {
        "class": "android.media.RingtoneManager",
        "api": "getValidRingtoneUri",
        "permissionText": "Returns a valid ringtone URI. No guarantees on which it returns. If it\n cannot find one, returns null. If it can only find one on external storage and the caller\n doesn't have the Manifest.permission.READ_EXTERNAL_STORAGE permission,\n returns null."
    },
    {
        "class": "android.content.RestrictionsManager",
        "api": "ACTION_REQUEST_PERMISSION",
        "permissionText": "The BroadcastReceiver must require the Manifest.permission.BIND_DEVICE_ADMIN\n permission to ensure that only the system can send the broadcast."
    },
    {
        "class": "android.os.RecoverySystem",
        "api": "installPackage",
        "permissionText": "Reboots the device in order to install the given update\n package.\n Requires the Manifest.permission.REBOOT permission.\n\n \n Requires android.Manifest.permission.RECOVERY"
    },
    {
        "class": "android.os.RecoverySystem",
        "api": "rebootWipeUserData",
        "permissionText": "Reboots the device and wipes the user data and cache\n partitions.  This is sometimes called a \"factory reset\", which\n is something of a misnomer because the system partition is not\n restored to its factory state.  Requires the\n Manifest.permission.REBOOT permission."
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "ACTION_PHONE_STATE_CHANGED",
        "permissionText": "The EXTRA_STATE extra indicates the new call state.\n If a receiving app has Manifest.permission.READ_CALL_LOG permission, a second\n extra EXTRA_INCOMING_NUMBER provides the phone number for incoming and outgoing\n calls as a String."
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "ACTION_RESPOND_VIA_MESSAGE",
        "permissionText": "Note:\n The intent-filter that consumes this Intent needs to be in a Service\n that requires the\n permission Manifest.permission.SEND_RESPOND_VIA_MESSAGE."
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "EXTRA_INCOMING_NUMBER",
        "permissionText": "This extra is only populated for receivers of the ACTION_PHONE_STATE_CHANGED\n broadcast which have been granted the Manifest.permission.READ_CALL_LOG and\n Manifest.permission.READ_PHONE_STATE permissions."
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "doesSwitchMultiSimConfigTriggerReboot",
        "permissionText": "Requires Permission:\n READ_PHONE_STATE or that the\n calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getAllCellInfo",
        "permissionText": "This method is preferred over using getCellLocation().\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getCarrierConfig",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n This method may take several seconds to complete, so it should\n only be called from a worker thread.\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getCellLocation",
        "permissionText": "Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getDataNetworkType",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getDeviceSoftwareVersion",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getEmergencyNumberList",
        "permissionText": "Requires permission Manifest.permission.READ_PHONE_STATE or the calling\n app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getEmergencyNumberList",
        "permissionText": "Requires permission Manifest.permission.READ_PHONE_STATE or the calling\n app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getForbiddenPlmns",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getGroupIdLevel1",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getLine1Number",
        "permissionText": "Requires Permission:\n     READ_PHONE_STATE,\n     READ_SMS,\n     READ_PHONE_NUMBERS,\n     that the caller is the default SMS app,\n     or that the caller has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE or Manifest.permission.READ_SMS or Manifest.permission.READ_PHONE_NUMBERS"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getNai",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getPreferredOpportunisticDataSubscription",
        "permissionText": "Requires that the calling app has carrier privileges (see hasCarrierPrivileges()),\n or has either READ_PRIVILEGED_PHONE_STATE\n or READ_PHONE_STATE permission.\n \n Requires android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE or Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getServiceState",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges())\n and Manifest.permission.ACCESS_COARSE_LOCATION.\n \n \n Requires Manifest.permission.READ_PHONE_STATE and Manifest.permission.ACCESS_COARSE_LOCATION"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getUiccCardsInfo",
        "permissionText": "See UiccCardInfo for more details on the kind of information available.\n\n \n Requires android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getVisualVoicemailPackageName",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getVoiceMailAlphaTag",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getVoiceMailNumber",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "getVoiceNetworkType",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "isDataEnabled",
        "permissionText": "Requires one of the following permissions:\n Manifest.permission.ACCESS_NETWORK_STATE,\n Manifest.permission.MODIFY_PHONE_STATE, or that the calling app has carrier\n privileges (see hasCarrierPrivileges())."
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "isDataRoamingEnabled",
        "permissionText": "Requires one of the following permissions:\n Manifest.permission.ACCESS_NETWORK_STATE,\n Manifest.permission.READ_PHONE_STATE or that the calling app\n has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.ACCESS_NETWORK_STATE or Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "isMultiSimSupported",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "requestCellInfoUpdate",
        "permissionText": "Any available results from this request will be provided by calls to\n onCellInfoChanged()\n for each active subscription.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "requestNetworkScan",
        "permissionText": "Requires Permission:\n MODIFY_PHONE_STATE or that the calling\n app has carrier privileges (see hasCarrierPrivileges())\n and Manifest.permission.ACCESS_FINE_LOCATION.\n\n If the system-wide location switch is off, apps may still call this API, with the\n following constraints:"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "sendUssdRequest",
        "permissionText": "Requires permission:\n Manifest.permission.CALL_PHONE\n \n Requires Manifest.permission.CALL_PHONE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "setDataEnabled",
        "permissionText": "Requires Permission:\n MODIFY_PHONE_STATE or that the calling\n app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "setNetworkSelectionModeAutomatic",
        "permissionText": "Requires Permission:\n MODIFY_PHONE_STATE or that the calling\n app has carrier privileges (see hasCarrierPrivileges()).\n \n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "setNetworkSelectionModeManual",
        "permissionText": "Requires Permission:\n MODIFY_PHONE_STATE or that the calling\n app has carrier privileges (see hasCarrierPrivileges()).\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.TelephonyManager",
        "api": "switchMultiSimConfig",
        "permissionText": "Requires Permission:\n MODIFY_PHONE_STATE or that the\n calling app has carrier privileges (see hasCarrierPrivileges()).\n\n Note: with only carrier privileges, it is not allowed to switch from multi-sim\n to single-sim\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "DATA_SMS_RECEIVED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SIM_FULL_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SMS_CB_RECEIVED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SMS_DELIVER_ACTION",
        "permissionText": "Note:\n The broadcast receiver that filters for this intent must declare\n Manifest.permission.BROADCAST_SMS as a required permission in\n the <receiver> tag."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SMS_RECEIVED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SMS_REJECTED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "SMS_SERVICE_CATEGORY_PROGRAM_DATA_RECEIVED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_SMS to receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "WAP_PUSH_DELIVER_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_MMS or\n Manifest.permission.RECEIVE_WAP_PUSH (depending on WAP PUSH type) to\n receive."
    },
    {
        "class": "android.provider.Telephony.Sms.Intents",
        "api": "WAP_PUSH_RECEIVED_ACTION",
        "permissionText": "Requires Manifest.permission.RECEIVE_MMS or\n Manifest.permission.RECEIVE_WAP_PUSH (depending on WAP PUSH type) to\n receive."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "acceptHandover",
        "permissionText": "This method is called from the receiving side of a handover to indicate a desire to\n accept the handover of an ongoing call to another ConnectionService identified by\n PhoneAccountHandle destAcct. For managed ConnectionServices, the specified\n PhoneAccountHandle must have been registered with registerPhoneAccount(PhoneAccount) and\n the user must have enabled the corresponding PhoneAccount.  This can be checked using\n getPhoneAccount(PhoneAccountHandle). Self-managed ConnectionServices must have\n Manifest.permission.MANAGE_OWN_CALLS to handover a call to it."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "acceptRingingCall",
        "permissionText": "If there is a ringing incoming call, this method accepts the call on behalf of the user,\n with the specified video state.\n\n Requires permission: Manifest.permission.MODIFY_PHONE_STATE or\n Manifest.permission.ANSWER_PHONE_CALLS\n\n \n Requires Manifest.permission.ANSWER_PHONE_CALLS or Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "acceptRingingCall",
        "permissionText": "If there is a ringing incoming call, this method accepts the call on behalf of the user.\n\n If the incoming call is a video call, the call will be answered with the same video state as\n the incoming call requests.  This means, for example, that an incoming call requesting\n VideoProfile#STATE_BIDIRECTIONAL will be answered, accepting that state.\n\n Requires permission: Manifest.permission.MODIFY_PHONE_STATE or\n Manifest.permission.ANSWER_PHONE_CALLS\n\n \n Requires Manifest.permission.ANSWER_PHONE_CALLS or Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "addNewIncomingCall",
        "permissionText": "Registers a new incoming call. A ConnectionService should invoke this method when it\n has an incoming call. For managed ConnectionServices, the specified\n PhoneAccountHandle must have been registered with registerPhoneAccount(PhoneAccount) and\n the user must have enabled the corresponding PhoneAccount.  This can be checked using\n getPhoneAccount(PhoneAccountHandle). Self-managed ConnectionServices must have\n Manifest.permission.MANAGE_OWN_CALLS to add a new incoming call."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "cancelMissedCallsNotification",
        "permissionText": "Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "endCall",
        "permissionText": "Requires permission Manifest.permission.ANSWER_PHONE_CALLS."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getAdnUriForPhoneAccount",
        "permissionText": "Requires permission: Manifest.permission.MODIFY_PHONE_STATE\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getCallCapablePhoneAccounts",
        "permissionText": "Returns a list of PhoneAccountHandles which can be used to make and receive phone\n calls. The returned list includes only those accounts which have been explicitly enabled\n by the user.\n\n Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getDefaultOutgoingPhoneAccount",
        "permissionText": "If no PhoneAccount fits the criteria above, this method will return null.\n\n Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getLine1Number",
        "permissionText": "Return the line 1 phone number for given phone account.\n\n Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getSelfManagedPhoneAccounts",
        "permissionText": "Requires permission Manifest.permission.READ_PHONE_STATE, or that the caller\n is the default dialer app."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getUserSelectedOutgoingPhoneAccount",
        "permissionText": "The default dialer has access to use this method.\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "getVoiceMailNumber",
        "permissionText": "Return the voicemail number for a given phone account.\n\n Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "handleMmi",
        "permissionText": "Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "handleMmi",
        "permissionText": "Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "isInCall",
        "permissionText": "Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "isInManagedCall",
        "permissionText": "Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "isTtySupported",
        "permissionText": "Returns whether TTY is supported on this device.\n \n \n Requires android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE or Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "isVoiceMailNumber",
        "permissionText": "Return whether a given phone number is the configured voicemail number for a\n particular phone account.\n\n Requires permission: Manifest.permission.READ_PHONE_STATE\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "placeCall",
        "permissionText": "Places a new outgoing call to the provided address using the system telecom service with\n the specified extras.\n\n This method is equivalent to placing an outgoing call using Intent#ACTION_CALL,\n except that the outgoing call will always be sent via the system telecom service. If\n method-caller is either the user selected default dialer app or preloaded system dialer\n app, then emergency calls will also be allowed.\n\n Placing a call via a managed ConnectionService requires permission:\n Manifest.permission.CALL_PHONE\n\n Usage example:"
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "showInCallScreen",
        "permissionText": "Requires that the method-caller be set as the system dialer app or have the\n Manifest.permission.READ_PHONE_STATE permission."
    },
    {
        "class": "android.telecom.TelecomManager",
        "api": "silenceRinger",
        "permissionText": "Requires permission: Manifest.permission.MODIFY_PHONE_STATE or that the\n app fills the dialer role (see getDefaultDialerPackage()).\n \n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.nfc.tech.TagTechnology",
        "api": "close",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.nfc.tech.TagTechnology",
        "api": "connect",
        "permissionText": "Requires the Manifest.permission.NFC permission."
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "addSubscriptionsIntoGroup",
        "permissionText": "Add a list of subscriptions into a group.\n See createSubscriptionGroup(java.util.List) for more details.\n\n Caller will either have Manifest.permission.MODIFY_PHONE_STATE\n permission or had carrier privilege permission on the subscriptions:\n TelephonyManager#hasCarrierPrivileges() or\n canManageSubscription(android.telephony.SubscriptionInfo)\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "createSubscriptionGroup",
        "permissionText": "Inform SubscriptionManager that subscriptions in the list are bundled\n as a group. It can be multiple primary (non-opportunistic) subscriptions,\n or one or more primary plus one or more opportunistic subscriptions.\n\n This API will always create a new immutable group and assign group UUID to all the\n subscriptions, regardless whether they are in a group already or not.\n\n Grouped subscriptions will have below behaviors:\n 1) They will share the same user settings.\n 2) The opportunistic subscriptions in the group is considered invisible and will not\n    return from getActiveSubscriptionInfoList(), unless caller has carrier\n    privilege permission of the subscriptions.\n 3) The opportunistic subscriptions in the group can't be active by itself. If all other\n    non-opportunistic ones are deactivated (unplugged or disabled in Settings),\n    the opportunistic ones will be deactivated automatically.\n\n Caller will either have Manifest.permission.MODIFY_PHONE_STATE\n permission or had carrier privilege permission on the subscriptions:\n TelephonyManager#hasCarrierPrivileges() or\n canManageSubscription(android.telephony.SubscriptionInfo)\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getActiveSubscriptionInfo",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see\n TelephonyManager#hasCarrierPrivileges).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getActiveSubscriptionInfoCount",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see\n TelephonyManager#hasCarrierPrivileges). In the latter case, the count will include\n only those subscriptions accessible to the caller.\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getActiveSubscriptionInfoForSimSlotIndex",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see\n TelephonyManager#hasCarrierPrivileges).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getActiveSubscriptionInfoList",
        "permissionText": "Requires Permission: READ_PHONE_STATE\n or that the calling app has carrier privileges (see\n TelephonyManager#hasCarrierPrivileges). In the latter case, only records accessible\n to the calling app are returned.\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getOpportunisticSubscriptions",
        "permissionText": "Requires Permission:\n READ_PHONE_STATE\n or that the calling app has carrier privileges (see\n TelephonyManager#hasCarrierPrivileges).\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "getSubscriptionsInGroup",
        "permissionText": "Get subscriptionInfo list of subscriptions that are in the same group of given subId.\n See createSubscriptionGroup(java.util.List) for more details.\n\n Caller will either have Manifest.permission.READ_PHONE_STATE\n permission or had carrier privilege permission on the subscription.\n TelephonyManager#hasCarrierPrivileges()\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "isActiveSubscriptionId",
        "permissionText": "Checks if the supplied subscription ID corresponds to a subscription which is actively in\n use on the device. An active subscription ID is a valid and usable subscription ID.\n\n \n Requires Manifest.permission.READ_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "removeSubscriptionsFromGroup",
        "permissionText": "Remove a list of subscriptions from their subscription group.\n See createSubscriptionGroup(java.util.List) for more details.\n\n Caller will either have Manifest.permission.MODIFY_PHONE_STATE\n permission or had carrier privilege permission on the subscriptions:\n TelephonyManager#hasCarrierPrivileges() or\n canManageSubscription(android.telephony.SubscriptionInfo)\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "setOpportunistic",
        "permissionText": "Set whether a subscription is opportunistic, that is, whether the network it connects\n to has limited coverage. For example, CBRS. Setting a subscription opportunistic has\n following impacts:\n  1) Even if it's active, it will be dormant most of the time. The modem will not try\n     to scan or camp until it knows an available network is nearby to save power.\n  2) Telephony relies on system app or carrier input to notify nearby available networks.\n     See TelephonyManager#updateAvailableNetworks(List, Executor, Consumer)\n     for more information.\n  3) In multi-SIM devices, when the network is nearby and camped, system may automatically\n     switch internet data between it and default data subscription, based on carrier\n     recommendation and its signal strength and metered-ness, etc.\n\n\n Caller will either have Manifest.permission.MODIFY_PHONE_STATE or carrier\n privilege permission of the subscription.\n\n \n Requires Manifest.permission.MODIFY_PHONE_STATE"
    },
    {
        "class": "android.telephony.SubscriptionManager",
        "api": "switchToSubscription",
        "permissionText": "Switch to a certain subscription\n\n\n \n Requires android.Manifest.permission.WRITE_EMBEDDED_SUBSCRIPTIONS"
    },
    {
        "class": "android.os.StrictMode.VmPolicy.Builder",
        "api": "detectFileUriExposure",
        "permissionText": "This exposure is discouraged since the receiving app may not have access to the\n shared path. For example, the receiving app may not have requested the Manifest.permission.READ_EXTERNAL_STORAGE runtime permission, or the\n platform may be sharing the Uri across user profile boundaries."
    },
    {
        "class": "android.os.storage.StorageVolume",
        "api": "createAccessIntent",
        "permissionText": "Access to the entire volume is only available for non-primary volumes (for the primary\n volume, apps can use the Manifest.permission.READ_EXTERNAL_STORAGE and\n Manifest.permission.WRITE_EXTERNAL_STORAGE permissions) and should be used\n with caution, since users are more likely to deny access when asked for entire volume access\n rather than specific directories."
    },
    {
        "class": "android.util.StatsLog",
        "api": "logBinaryPushStateChanged",
        "permissionText": "Logs an event for binary push for module updates.\n\n \n Requires Manifest.permission.DUMP and Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "getSmsMessagesForFinancialApp",
        "permissionText": "Manifest.permission.SMS_FINANCIAL_TRANSACTIONS"
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "injectSmsPdu",
        "permissionText": "Requires permission: Manifest.permission.MODIFY_PHONE_STATE or carrier\n privileges per TelephonyManager.hasCarrierPrivileges()."
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "sendDataMessage",
        "permissionText": "Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "sendMultipartTextMessage",
        "permissionText": "Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "sendTextMessage",
        "permissionText": "Note: Using this method requires that your app has the\n Manifest.permission.SEND_SMS permission."
    },
    {
        "class": "android.telephony.SmsManager",
        "api": "sendTextMessageWithoutPersisting",
        "permissionText": "Requires Permission: Both Manifest.permission.SEND_SMS and\n Manifest.permission.MODIFY_PHONE_STATE, or that the calling app has carrier\n privileges (see TelephonyManager#hasCarrierPrivileges), or that the calling app is\n the default IMS app (see\n CarrierConfigManager#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING)."
    },
    {
        "class": "android.net.wifi.rtt.WifiRttManager",
        "api": "startRanging",
        "permissionText": "Initiate a request to range to a set of devices specified in the RangingRequest.\n Results will be returned in the RangingResultCallback set of callbacks.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION and Manifest.permission.CHANGE_WIFI_STATE and Manifest.permission.ACCESS_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "WIFI_P2P_CONNECTION_CHANGED_ACTION",
        "permissionText": "Broadcast intent action indicating that the state of Wi-Fi p2p connectivity\n has changed. One extra EXTRA_WIFI_P2P_INFO provides the p2p connection info in\n the form of a WifiP2pInfo object. Another extra EXTRA_NETWORK_INFO provides\n the network info in the form of a NetworkInfo. A third extra provides\n the details of the group.\n\n All of these permissions are required to receive this broadcast:\n Manifest.permission.ACCESS_FINE_LOCATION and\n Manifest.permission.ACCESS_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "WIFI_P2P_PEERS_CHANGED_ACTION",
        "permissionText": "Broadcast intent action indicating that the available peer list has changed. This\n can be sent as a result of peers being found, lost or updated.\n\n All of these permissions are required to receive this broadcast:\n Manifest.permission.ACCESS_FINE_LOCATION and\n Manifest.permission.ACCESS_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "WIFI_P2P_THIS_DEVICE_CHANGED_ACTION",
        "permissionText": "The EXTRA_WIFI_P2P_DEVICE extra contains an anonymized version of the device's\n MAC address. Callers holding the android.Manifest.permission#LOCAL_MAC_ADDRESS\n permission can use requestDeviceInfo(WifiP2pManager.Channel, WifiP2pManager.DeviceInfoListener) to obtain the actual MAC address of this\n device.\n\n All of these permissions are required to receive this broadcast:\n Manifest.permission.ACCESS_FINE_LOCATION and\n Manifest.permission.ACCESS_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "addLocalService",
        "permissionText": "The service information can be cleared with calls to\n  removeLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) or clearLocalServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener).\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "connect",
        "permissionText": "If the current device is part of an existing p2p group or has created\n a p2p group with createGroup(WifiP2pManager.Channel, WifiP2pConfig, WifiP2pManager.ActionListener), an invitation to join the group is sent to\n the peer device.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "createGroup",
        "permissionText": "Application can request for the group details with requestGroupInfo(WifiP2pManager.Channel, WifiP2pManager.GroupInfoListener).\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "createGroup",
        "permissionText": "Application can request for the group details with requestGroupInfo(WifiP2pManager.Channel, WifiP2pManager.GroupInfoListener).\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "discoverPeers",
        "permissionText": "Upon receiving a WIFI_P2P_PEERS_CHANGED_ACTION intent, an application\n can request for the list of peers using requestPeers(WifiP2pManager.Channel, WifiP2pManager.PeerListListener).\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "discoverServices",
        "permissionText": "The application is notified of the response against the service discovery request\n through listener callbacks registered by setServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.ServiceResponseListener) or\n setDnsSdResponseListeners(WifiP2pManager.Channel, WifiP2pManager.DnsSdServiceResponseListener, WifiP2pManager.DnsSdTxtRecordListener), or setUpnpServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.UpnpServiceResponseListener).\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "requestDeviceInfo",
        "permissionText": "This information is also included in the WIFI_P2P_THIS_DEVICE_CHANGED_ACTION\n broadcast event with extra EXTRA_WIFI_P2P_DEVICE.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "requestGroupInfo",
        "permissionText": "Request p2p group info.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.p2p.WifiP2pManager",
        "api": "requestPeers",
        "permissionText": "Request the current list of peers.\n\n \n Requires Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "EXTRA_RESULTS_UPDATED",
        "permissionText": "An app requested too many scans in a certain period of time.\n This may lead to additional scan request rejections via \"scan throttling\" for both\n foreground and background apps.\n Note: Apps holding android.Manifest.permission.NETWORK_SETTINGS permission are\n exempted from scan throttling.\n \n The device is idle and scanning is disabled.\n Wifi hardware reported a scan failure."
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "RSSI_CHANGED_ACTION",
        "permissionText": "The RSSI (signal strength) has changed.\n\n Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "addNetworkSuggestions",
        "permissionText": "Manifest.permission.CHANGE_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "getConfiguredNetworks",
        "permissionText": "Manifest.permission.ACCESS_FINE_LOCATION"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "getPasspointConfigurations",
        "permissionText": "Return the list of installed Passpoint configurations.\n\n An empty list will be returned when no configurations are installed.\n\n \n Requires android.Manifest.permission.NETWORK_SETTINGS or android.Manifest.permission.NETWORK_SETUP_WIZARD"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "removeNetworkSuggestions",
        "permissionText": "Remove some or all of the network suggestions that were previously provided by the app.\n See WifiNetworkSuggestion for a detailed explanation of the parameters.\n See WifiNetworkSuggestion#equals(Object) for the equivalence evaluation used.\n\n \n Requires Manifest.permission.CHANGE_WIFI_STATE"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "removePasspointConfiguration",
        "permissionText": "Remove the Passpoint configuration identified by its FQDN (Fully Qualified Domain Name).\n\n \n Requires android.Manifest.permission.NETWORK_SETTINGS"
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "setWifiEnabled",
        "permissionText": "Applications must have the Manifest.permission.CHANGE_WIFI_STATE\n permission to toggle wifi."
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "startLocalOnlyHotspot",
        "permissionText": "Applications need to have the following permissions to start LocalOnlyHotspot: Manifest.permission.CHANGE_WIFI_STATE and ACCESS_FINE_LOCATION.  Callers without\n the permissions will trigger a SecurityException."
    },
    {
        "class": "android.net.wifi.WifiManager",
        "api": "startScan",
        "permissionText": "To initiate a Wi-Fi scan, declare the\n Manifest.permission.CHANGE_WIFI_STATE\n permission in the manifest, and perform these steps:"
    },
    {
        "class": "android.net.wifi.aware.WifiAwareSession",
        "api": "publish",
        "permissionText": "The application must have the Manifest.permission.ACCESS_FINE_LOCATION\n permission to start a publish discovery session."
    },
    {
        "class": "android.net.wifi.aware.WifiAwareSession",
        "api": "subscribe",
        "permissionText": "The application must have the Manifest.permission.ACCESS_FINE_LOCATION\n permission to start a subscribe discovery session."
    },
    {
        "class": "android.net.wifi.aware.WifiAwareManager",
        "api": "attach",
        "permissionText": "This version of the API attaches a listener to receive the MAC address of the Aware interface\n on startup and whenever it is updated (it is randomized at regular intervals for privacy).\n The application must have the Manifest.permission.ACCESS_FINE_LOCATION\n permission to execute this attach request. Otherwise, use the\n attach(android.net.wifi.aware.AttachCallback, android.os.Handler) version. Note that aside from permission\n requirements this listener will wake up the host at regular intervals causing higher power\n consumption, do not use it unless the information is necessary (e.g. for OOB discovery)."
    },
    {
        "class": "android.webkit.WebSettings",
        "api": "setBlockNetworkLoads",
        "permissionText": "Sets whether the WebView should not load resources from the network.\n Use setBlockNetworkImage(boolean) to only avoid loading\n image resources. Note that if the value of this setting is\n changed from true to false, network resources referenced by content\n currently displayed by the WebView are not fetched until\n WebView.reload() is called.\n If the application does not have the\n Manifest.permission.INTERNET permission, attempts to set\n a value of false will cause a SecurityException\n to be thrown. The default value is false if the application has the\n Manifest.permission.INTERNET permission, otherwise it is\n true."
    },
    {
        "class": "android.webkit.WebSettings",
        "api": "setGeolocationEnabled",
        "permissionText": "an application must have permission to access the device location,\n   see Manifest.permission.ACCESS_COARSE_LOCATION,\n   Manifest.permission.ACCESS_FINE_LOCATION;\n   an application must provide an implementation of the\n   WebChromeClient#onGeolocationPermissionsShowPrompt callback\n   to receive notifications that a page is requesting access to location\n   via the JavaScript Geolocation API."
    },
    {
        "class": "android.service.wallpaper.WallpaperService",
        "api": "SERVICE_INTERFACE",
        "permissionText": "The Intent that must be declared as handled by the service.\n To be supported, the service must also require the\n Manifest.permission.BIND_WALLPAPER permission so\n that other applications can not abuse it."
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "clear",
        "permissionText": "Remove one or more currently set wallpapers, reverting to the system default\n display for each one.  If FLAG_SYSTEM is set in the which\n parameter, the intent Intent#ACTION_WALLPAPER_CHANGED will be broadcast\n upon success.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "clear",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "clearWallpaper",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n \n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "getFastDrawable",
        "permissionText": "Like getDrawable(), but the returned Drawable has a number\n of limitations to reduce its overhead as much as possible. It will\n never scale the wallpaper (only centering it if the requested bounds\n do match the bitmap bounds, which should not be typical), doesn't\n allow setting an alpha, color filter, or other attributes, etc.  The\n bounds of the returned drawable will be initialized to the same bounds\n as the wallpaper, so normally you will not need to touch it.  The\n drawable also assumes that it will be used in a context running in\n the same density as the screen (not in density compatibility mode).\n\n \n Requires Manifest.permission.READ_EXTERNAL_STORAGE"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "getWallpaperFile",
        "permissionText": "If no lock-specific wallpaper has been configured for the given user, then\n this method will return null when requesting FLAG_LOCK rather than\n returning the system wallpaper's image file.\n\n \n Requires Manifest.permission.READ_EXTERNAL_STORAGE"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "peekFastDrawable",
        "permissionText": "Like getFastDrawable(), but if there is no wallpaper set,\n a null pointer is returned.\n\n \n Requires Manifest.permission.READ_EXTERNAL_STORAGE"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setBitmap",
        "permissionText": "Version of setBitmap(android.graphics.Bitmap, android.graphics.Rect, boolean) that allows the caller\n to specify which of the supported wallpaper categories to set.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setBitmap",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setBitmap",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setDisplayPadding",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER_HINTS.\n\n \n Requires Manifest.permission.SET_WALLPAPER_HINTS"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setResource",
        "permissionText": "Version of setResource(int) that allows the caller to specify which\n of the supported wallpaper categories to set.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setResource",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setStream",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setStream",
        "permissionText": "Version of setStream(java.io.InputStream, android.graphics.Rect, boolean) that allows the caller\n to specify which of the supported wallpaper categories to set.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "setStream",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER.\n\n \n Requires Manifest.permission.SET_WALLPAPER"
    },
    {
        "class": "android.app.WallpaperManager",
        "api": "suggestDesiredDimensions",
        "permissionText": "This method requires the caller to hold the permission\n Manifest.permission.SET_WALLPAPER_HINTS."
    },
    {
        "class": "android.net.VpnService",
        "api": "SERVICE_INTERFACE",
        "permissionText": "The action must be matched by the intent filter of this service. It also\n needs to require Manifest.permission.BIND_VPN_SERVICE\n permission so that other applications cannot abuse it."
    },
    {
        "class": "android.service.voice.VoiceInteractionService",
        "api": "SERVICE_INTERFACE",
        "permissionText": "The Intent that must be declared as handled by the service.\n To be supported, the service must also require the\n Manifest.permission.BIND_VOICE_INTERACTION permission so\n that other applications can not abuse it."
    },
    {
        "class": "android.os.Vibrator",
        "api": "cancel",
        "permissionText": "Turn the vibrator off.\n \n \n Requires Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Vibrate constantly for the specified period of time.\n\n \n Requires Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Requires Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Requires Manifest.permission.VIBRATE"
    },
    {
        "class": "android.os.Vibrator",
        "api": "vibrate",
        "permissionText": "Vibrate constantly for the specified period of time.\n\n \n Requires Manifest.permission.VIBRATE"
    },
    {
        "class": "android.hardware.usb.UsbManager",
        "api": "hasPermission",
        "permissionText": "Returns true if the caller has permission to access the device.\n Permission might have been granted temporarily via\n requestPermission(android.hardware.usb.UsbDevice, android.app.PendingIntent) or\n by the user choosing the caller as the default application for the device.\n Permission for USB devices of class UsbConstants#USB_CLASS_VIDEO for clients that\n target SDK Build.VERSION_CODES.P and above can be granted only if they\n have additionally the Manifest.permission.CAMERA permission.\n\n \n Requires the PackageManager#FEATURE_USB_HOST feature which can be detected using PackageManager.hasSystemFeature(String)."
    },
    {
        "class": "android.hardware.usb.UsbManager",
        "api": "requestPermission",
        "permissionText": "Manifest.permission.CAMERA"
    },
    {
        "class": "android.app.usage.UsageStatsManager",
        "api": "queryAndAggregateUsageStats",
        "permissionText": "The caller must have Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.app.usage.UsageStatsManager",
        "api": "queryConfigurations",
        "permissionText": "The caller must have Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.app.usage.UsageStatsManager",
        "api": "queryEventStats",
        "permissionText": "The caller must have Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.app.usage.UsageStatsManager",
        "api": "queryEvents",
        "permissionText": "The caller must have Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.app.usage.UsageStatsManager",
        "api": "queryUsageStats",
        "permissionText": "The caller must have Manifest.permission.PACKAGE_USAGE_STATS"
    },
    {
        "class": "android.media.tv.TvInputService",
        "api": "SERVICE_INTERFACE",
        "permissionText": "This is the interface name that a service implementing a TV input should say that it support\n -- that is, this is the action it uses for its intent filter. To be supported, the service\n must also require the Manifest.permission.BIND_TV_INPUT permission so that\n other applications cannot abuse it."
    }
]